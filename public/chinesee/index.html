<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Coffee Checkers">
    <meta name="theme-color" content="#d4af37">
    <title>Coffee Checkers - Multiplayer</title>
    <style>
        :root {
            --light-square: #d4af37;
            --dark-square: #8b4513;
            --piece-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c1810, #4a2c20, #3d2817);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #f4e4c1;
            margin: 0;
            padding: 5px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .game-container {
            background: linear-gradient(135deg, rgba(26, 18, 12, 0.95), rgba(44, 24, 16, 0.95), rgba(61, 40, 23, 0.95));
            border-radius: 20px;
            padding: 3px;
            backdrop-filter: blur(20px) saturate(180%);
            border: 3px solid rgba(212, 175, 55, 0.2);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3), 
                0 10px 20px rgba(139, 69, 19, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 100vw;
            max-height: 100vh;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            justify-content: flex-start;
            position: relative;
        }

        .game-title {
            text-align: center;
            font-size: 2em;
            margin-bottom: 1px;
            background: linear-gradient(135deg, #d4af37, #f4e4c1, #d4af37);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 8px rgba(212, 175, 55, 0.3);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
            padding: 6px 12px;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.3), rgba(160, 82, 45, 0.2));
            border-radius: 12px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            font-size: 0.9em;
            backdrop-filter: blur(8px);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(139, 69, 19, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-score {
            font-size: 1.4em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.5px;
        }

        .current-player {
            background: linear-gradient(135deg, #d4af37, #f4e4c1);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8);
            font-weight: 600;
            animation: glow-pulse 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow-pulse {
            from { filter: drop-shadow(0 0 5px rgba(212, 175, 55, 0.5)); }
            to { filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.9)); }
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 58px);
            grid-template-rows: repeat(8, 58px);
            gap: 1px;
            background: linear-gradient(135deg, #2f1b14, #3d2817, #2f1b14);
            padding: 8px;
            border-radius: 16px;
            border: 3px solid transparent;
            background-clip: padding-box;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 4px 16px rgba(139, 69, 19, 0.3),
                inset 0 2px 4px rgba(212, 175, 55, 0.1);
            margin: 2px auto;
            max-width: fit-content;
            flex-shrink: 0;
            position: relative;
        }
        
        .board::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(135deg, #d4af37, #8b4513, #d4af37);
            border-radius: 16px;
            z-index: -1;
        }

        .cell {
            width: 58px;
            height: 58px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
            position: relative;
        }

        .cell.light {
            background: linear-gradient(135deg, var(--light-square), #deb887, #d2b48c);
            border: 1px solid #d2b48c;
            box-shadow: inset 0 1px 3px rgba(139, 69, 19, 0.2);
        }

        .cell.dark {
            background: linear-gradient(135deg, var(--dark-square), #a0522d, #654321);
            border: 1px solid #4a2c20;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .cell.selected {
            box-shadow: 0 0 20px #d4af37, inset 0 0 10px rgba(212, 175, 55, 0.5);
            border: 3px solid #d4af37;
            animation: selection-glow 1.5s ease-in-out infinite alternate;
        }

        @keyframes selection-glow {
            0% { box-shadow: 0 0 20px #d4af37, inset 0 0 10px rgba(212, 175, 55, 0.5); }
            100% { box-shadow: 0 0 30px #d4af37, inset 0 0 15px rgba(212, 175, 55, 0.8); }
        }

        .cell.valid-move {
            background: radial-gradient(circle, rgba(212, 175, 55, 0.4) 0%, transparent 70%);
            animation: pulse 1s infinite;
            border: 2px solid rgba(212, 175, 55, 0.6);
        }

        .cell.must-capture {
            background: radial-gradient(circle, rgba(220, 20, 60, 0.5) 0%, transparent 70%);
            animation: pulse 1s infinite;
            border: 2px solid rgba(220, 20, 60, 0.8);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .piece {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        .piece.player1 {
            background: linear-gradient(135deg, #4a2c20, #6f4e37, #8b4513);
            border: 3px solid #2c1810;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4), inset 0 1px 3px rgba(255, 255, 255, 0.2);
        }

        .piece.player2 {
            background: linear-gradient(135deg, #f5e6d3, #f4e4c1, #deb887);
            border: 3px solid #d2b48c;
            color: #2c1810;
            text-shadow: 1px 1px 3px rgba(255, 255, 255, 0.6);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4), inset 0 1px 3px rgba(139, 69, 19, 0.3);
        }

        .piece.king {
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.9), 0 3px 8px rgba(0, 0, 0, 0.4);
            border: 4px solid #d4af37;
            animation: royal-glow 2s ease-in-out infinite alternate;
        }

        @keyframes royal-glow {
            0% { box-shadow: 0 0 20px rgba(212, 175, 55, 0.9), 0 3px 8px rgba(0, 0, 0, 0.4); }
            100% { box-shadow: 0 0 30px rgba(212, 175, 55, 1), 0 3px 8px rgba(0, 0, 0, 0.4); }
        }

        .piece:hover {
            transform: scale(1.15);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            filter: brightness(1.1);
        }
        
        /* Mobile touch improvements */
        @media (hover: none) and (pointer: coarse) {
            .piece {
                transition: all 0.2s ease;
            }
            
            .piece:active {
            transform: scale(1.1);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
                z-index: 10;
            }
            
            .cell.selected {
                animation: mobile-selected 1.5s ease-in-out infinite alternate;
            }
            
            .cell.valid-move {
                border: 2px solid rgba(76, 175, 80, 0.8);
                animation: mobile-valid-move 2s ease-in-out infinite;
            }
            
            .cell.must-capture {
                border: 2px solid rgba(244, 67, 54, 0.9);
                animation: mobile-must-capture 1s ease-in-out infinite alternate;
            }
        }
        
        @keyframes mobile-selected {
            from { box-shadow: 0 0 15px #d4af37; }
            to { box-shadow: 0 0 25px #d4af37, inset 0 0 15px rgba(212, 175, 55, 0.3); }
        }
        
        @keyframes mobile-valid-move {
            0%, 100% { border-color: rgba(76, 175, 80, 0.8); }
            50% { border-color: rgba(76, 175, 80, 1); }
        }
        
        @keyframes mobile-must-capture {
            from { border-color: rgba(244, 67, 54, 0.9); }
            to { border-color: rgba(244, 67, 54, 1); }
        }

        .piece.player1:hover {
            box-shadow: 0 8px 20px rgba(139, 69, 19, 0.6), 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .piece.player2:hover {
            box-shadow: 0 8px 20px rgba(212, 175, 55, 0.6), 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #8b4513, #a0522d);
            color: #f4e4c1;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.7em;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(160, 82, 45, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(139, 69, 19, 0.2);
            backdrop-filter: blur(8px);
        }

        .btn:hover {
            background: linear-gradient(135deg, #a0522d, #cd853f);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25), 0 4px 8px rgba(139, 69, 19, 0.3);
            border-color: rgba(212, 175, 55, 0.6);
        }

        .game-over {
            text-align: center;
            padding: 20px;
            background: rgba(139, 69, 19, 0.2);
            border-radius: 10px;
            margin-top: 20px;
            border: 2px solid #d4af37;
        }

        .winner {
            font-size: 3em;
            color: #d4af37;
            margin-bottom: 10px;
        }

        .coffee-steam {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 18px;
            background: linear-gradient(transparent, rgba(255, 255, 255, 0.8), transparent);
            animation: steam 2s infinite;
            border-radius: 2px;
        }

        @keyframes steam {
            0% { opacity: 0; transform: translateX(-50%) translateY(0); }
            50% { opacity: 1; transform: translateX(-50%) translateY(-5px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }

        .rules-text {
            font-size: 1.8em;
            line-height: 1.4;
            text-align: left;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Battle UI Stilleri */
        .battle-info {
            background: linear-gradient(135deg, #d4af37, #f4e4c1);
            color: #2c1810;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3);
            animation: battlePulse 2s infinite;
        }

        @keyframes battlePulse {
            0%, 100% { transform: scale(1); box-shadow: 0 5px 15px rgba(212, 175, 55, 0.3); }
            50% { transform: scale(1.02); box-shadow: 0 8px 25px rgba(212, 175, 55, 0.5); }
        }

        .wallet-info {
            background: rgba(139, 69, 19, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            border: 1px solid rgba(160, 82, 45, 0.3);
        }

        .battle-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(139, 69, 19, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border: 1px solid rgba(160, 82, 45, 0.2);
        }

        .timer-display {
            font-size: 3em;
            font-weight: bold;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .stake-info {
            background: linear-gradient(135deg, #8b4513, #a0522d);
            color: #f4e4c1;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 1.8em;
            margin: 5px;
        }

        .btn.battle-btn {
            background: linear-gradient(135deg, #d4af37, #f4e4c1);
            color: #2c1810;
            border: 2px solid #d4af37;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3), 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .btn.battle-btn:hover {
            background: linear-gradient(135deg, #f4e4c1, #fff);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 30px rgba(212, 175, 55, 0.5), 0 5px 15px rgba(0, 0, 0, 0.15);
            border-color: #f4e4c1;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .game-container {
            max-width: 95vw;
            width: 100%;
            height: 95vh;
        }

        .controls {
            flex-wrap: wrap;
            gap: 10px;
        }

        .controls .btn {
            margin: 5px;
            min-width: 120px;
        }

        /* Mobile First Responsive Design - COMPLETELY OPTIMIZED */
        @media (max-width: 768px) {
            /* Prevent horizontal scroll and fix viewport */
            html, body {
                overflow-x: hidden;
                max-width: 100vw;
                height: 100vh;
                position: fixed;
            }
            
            .game-container {
                padding: 2px;
                margin: 0;
                height: 100vh;
                flex-direction: column;
                gap: 2px;
                border-radius: 8px;
                border: 1px solid rgba(212, 175, 55, 0.3);
                overflow: hidden;
                box-sizing: border-box;
            }
            
            /* Top game info - more compact */
            .game-info {
                padding: 3px 8px;
                margin-bottom: 1px;
                font-size: 0.75em;
                border-radius: 6px;
                order: 0;
            }
            
            .player-score {
                font-size: 1em;
            }
            
            /* Main layout: Board priority, controls below */
            .main-game-area {
                flex-direction: column !important;
                gap: 2px !important;
                max-height: calc(100vh - 60px) !important;
                min-height: 0;
                padding: 0;
                overflow: hidden;
            }
            
            /* Board container - centered and responsive */
            .board-container {
                order: 1;
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                padding: 0 2px !important;
                margin: 0 auto;
                flex: 0 0 auto;
                max-width: 100vw;
                box-sizing: border-box;
            }
            
            .board {
                grid-template-columns: repeat(8, min(calc((100vw - 30px) / 8), 68px));
                grid-template-rows: repeat(8, min(calc((100vw - 30px) / 8), 68px));
                gap: 1px;
                padding: 4px;
                margin: 0 auto;
                border-radius: 12px;
                max-width: calc(100vw - 10px);
                box-sizing: border-box;
            }
            
            .cell {
                width: min(calc((100vw - 30px) / 8), 68px);
                height: min(calc((100vw - 30px) / 8), 68px);
                border-radius: 3px;
            }
            
            .piece {
                width: calc(min(calc((100vw - 30px) / 8), 68px) - 8px);
                height: calc(min(calc((100vw - 30px) / 8), 68px) - 8px);
                font-size: calc(min(calc((100vw - 30px) / 8), 68px) * 0.4);
                border-width: 2px;
            }
            
            /* Controls below board - horizontal layout */
            .left-panel, .right-panel {
                order: 2;
                flex-direction: row !important;
                min-width: auto !important;
                max-width: none !important;
                width: 100% !important;
                gap: 2px !important;
                flex: 0 0 auto;
                max-height: 140px;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .left-panel > div, .right-panel > div {
                flex: 1;
                background: rgba(139, 69, 19, 0.25) !important;
                border: 1px solid rgba(212, 175, 55, 0.4) !important;
                border-radius: 8px !important;
                padding: 4px !important;
                margin: 0 1px !important;
                font-size: 0.7em !important;
                min-height: 70px;
                max-height: 100px;
                overflow-y: auto;
                backdrop-filter: blur(5px);
                box-sizing: border-box;
            }
            
            /* Compact button styling */
            .btn {
                padding: 4px 6px !important;
                font-size: 0.7em !important;
                margin: 1px 0 !important;
                border-radius: 6px !important;
                min-height: 28px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                line-height: 1.2;
                transition: all 0.2s ease;
                touch-action: manipulation;
            }
            
            .btn:active {
                transform: scale(0.95);
                background: rgba(212, 175, 55, 0.3) !important;
            }
            
            /* Touch-friendly improvements */
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .controls .btn {
                width: 100%;
                margin: 1px 0;
            }
            
            /* Panel headers more compact */
            .left-panel > div > div:first-child,
            .right-panel > div > div:first-child {
                font-size: 0.9em;
                margin-bottom: 2px;
                font-weight: bold;
                text-align: center;
            }
            
            /* Winner panel optimized for mobile */
            .winner-panel {
                position: fixed !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                z-index: 1000 !important;
                max-width: 95vw !important;
                max-height: 90vh !important;
                overflow-y: auto;
                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            }
            
            /* Status banner optimized */
            #game-status-banner {
                position: relative;
                top: 0;
                transform: none;
                width: 100%;
                margin-bottom: 3px;
                font-size: 0.75em;
                padding: 3px 6px;
                border-radius: 6px;
            }
            
            /* Scrollable content with touch optimization */
            #open-rooms-list {
                max-height: 80px;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
            }
            
            #battle-info-display {
                max-height: 100px;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            /* Room cards more compact */
            .room-card {
                margin: 1px 0 !important;
                padding: 4px !important;
                border-radius: 6px !important;
                font-size: 0.65em !important;
            }
            
            .room-card .btn {
                font-size: 0.6em !important;
                padding: 2px 4px !important;
                min-height: 20px !important;
            }
            
            /* Safe area for mobile keyboards */
            .main-game-area {
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }
            
            /* Hide mobile notice faster */
            #mobile-notice {
                font-size: 0.6em !important;
                padding: 2px !important;
                margin: 1px !important;
            }
            
            /* Optimize modals for mobile */
            #create-room-modal > div,
            #join-modal > div {
                max-width: 95vw !important;
                margin: 0 !important;
                border-radius: 12px !important;
                padding: 15px !important;
            }
            
            #create-room-modal input,
            #join-modal input {
                font-size: 16px !important; /* Prevents zoom on iOS */
                padding: 12px !important;
            }
        }
        
        /* Extra small screens (phones in portrait) - Enhanced */
        @media (max-width: 480px) {
            .board {
                grid-template-columns: repeat(8, min(calc((100vw - 20px) / 8), 60px)) !important;
                grid-template-rows: repeat(8, min(calc((100vw - 20px) / 8), 60px)) !important;
                padding: 3px !important;
            }
            
            .cell {
                width: min(calc((100vw - 20px) / 8), 60px) !important;
                height: min(calc((100vw - 20px) / 8), 60px) !important;
            }
            
            .piece {
                width: calc(min(calc((100vw - 20px) / 8), 60px) - 6px) !important;
                height: calc(min(calc((100vw - 20px) / 8), 60px) - 6px) !important;
                font-size: calc(min(calc((100vw - 20px) / 8), 60px) * 0.35) !important;
            }
            
            .btn {
                font-size: 0.65em !important;
                padding: 3px 5px !important;
                min-height: 24px !important;
            }
            
            .left-panel > div, .right-panel > div {
                font-size: 0.65em !important;
                padding: 3px !important;
                min-height: 60px !important;
            }
        }
        
        /* Timer display for mobile */
        .player-timer-box {
            background: rgba(139, 69, 19, 0.3);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 6px;
            padding: 4px 6px;
            margin: 2px 0;
            text-align: center;
            font-size: 0.8em;
            font-weight: bold;
            color: #f4e4c1;
            transition: all 0.3s ease;
        }
        
        .player-timer-box.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        
        @media (max-width: 768px) {
            .player-timer-box {
                font-size: 0.7em;
                padding: 2px 4px;
                margin: 1px 0;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="game-title">☕ Coffee Checkers ☕</h1>
        <div style="text-align: center; margin-bottom: 1px; background: linear-gradient(90deg, #d4af37, #f4e4c1, #d4af37); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-size: 0.8em; font-weight: 500; letter-spacing: 0.3px;">
            ⚡ Blockchain Checkers • Stake & Win! ⚡
        </div>
        
        <!-- Mobile Notice -->
        <div id="mobile-notice" style="display: none; text-align: center; background: rgba(212, 175, 55, 0.1); border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 6px; padding: 4px; margin: 2px; font-size: 0.7em; color: #d4af37;">
            📱 Touch to play
        </div>
        
        <!-- Status Banner moved to left panel -->
        
        <div class="game-info">
            <div class="player-info">
                <div class="player-score">
                    <span id="player1-label">☕</span>: <span id="player1-score">12</span>
                </div>
            </div>
            <div id="current-turn" class="current-player">☕ Turn</div>
            <div class="player-info">
                <div class="player-score">
                    <span id="player2-label">🥛</span>: <span id="player2-score">12</span>
                </div>
            </div>
        </div>

        <!-- Main Game Layout: Horizontal -->
        <div class="main-game-area" style="
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: 10px;
            flex: 1;
            max-height: calc(100vh - 80px);
            min-height: 0;
        ">
            <!-- Left Panel: Wallet & Controls -->
            <div class="left-panel" style="
                display: flex;
                flex-direction: column;
                gap: 5px;
                min-width: 160px;
                max-width: 180px;
            ">
                <!-- Game Status (moved from top) -->
                <div id="game-status-banner" style="
                    background: linear-gradient(135deg, #2c5530, #4a7c59);
                    border: 1px solid #d4af37;
                    border-radius: 6px;
                    padding: 5px 8px;
                    text-align: center;
                    color: #f4e4c1;
                    font-weight: bold;
                    font-size: 0.8em;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                    display: none;
                    transition: all 0.3s ease;
                    margin-bottom: 3px;
                ">
                    <span id="status-text">🎮 Ready to play</span>
                </div>

                <!-- Wallet Section -->
                <div id="wallet-panel" style="
                    background: rgba(139, 69, 19, 0.2);
                    border: 1px solid rgba(212, 175, 55, 0.3);
                    border-radius: 8px;
                    padding: 8px;
                    font-size: 1.6em;
                ">
                    <div style="margin-bottom: 2px; color: #d4af37; font-weight: bold; font-size: 1em; text-align: center;">💼</div>
                    <span id="wallet-address" style="display: none; color: #f4e4c1; font-size: 0.8em; word-break: break-all;"></span>
                    <button class="btn" id="connect-btn" onclick="connectWallet()" style="width: 100%; padding: 3px; font-size: 0.85em; margin-top: 2px;">🔗 Connect</button>
                    <div id="wallet-status" style="font-size: 1.4em; color: #f4e4c1; margin-top: 4px;"></div>
                </div>

                <!-- Game Controls -->
                <div id="game-controls" style="
                    background: linear-gradient(135deg, rgba(139, 69, 19, 0.3), rgba(160, 82, 45, 0.2));
                    border: 2px solid rgba(212, 175, 55, 0.4);
                    border-radius: 16px;
                    padding: 12px;
                    backdrop-filter: blur(10px);
                    box-shadow: 
                        0 8px 20px rgba(0, 0, 0, 0.15),
                        0 4px 8px rgba(139, 69, 19, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    transition: all 0.3s ease;
                ">
                    <div style="margin-bottom: 1px; color: #d4af37; font-weight: bold; font-size: 1em; text-align: center;">🎮</div>
                    <button class="btn" id="create-game-btn" onclick="showCreateRoomModal()" style="width: 100%; margin-bottom: 2px; padding: 3px; font-size: 0.8em;">🎯 Create Room</button>
                    <button class="btn" id="join-game-btn" onclick="showJoinModal()" style="width: 100%; margin-bottom: 2px; padding: 3px; font-size: 0.8em;">⚡ Join by ID</button>
                    <button class="btn" id="quick-match-btn" onclick="startQuickMatch()" style="width: 100%; margin-bottom: 2px; padding: 3px; font-size: 0.8em;">⚡ Quick Match</button>
                    <button class="btn" onclick="newGame()" style="width: 100%; padding: 3px; font-size: 0.75em;">🔄 Solo</button>
                </div>
                
                <!-- Tema & Ses Kontrolleri -->
                <div style="
                    background: linear-gradient(135deg, rgba(139, 69, 19, 0.3), rgba(160, 82, 45, 0.2));
                    border: 2px solid rgba(212, 175, 55, 0.3);
                    border-radius: 12px;
                    padding: 4px;
                    margin-bottom: 2px;
                    backdrop-filter: blur(8px);
                ">
                    <div style="margin-bottom: 2px; color: #d4af37; font-weight: bold; font-size: 0.9em; text-align: center;">🎨 Settings</div>
                    <select id="theme-selector" onchange="changeTheme(this.value)" style="width: 100%; margin-bottom: 2px; padding: 2px; background: rgba(44, 24, 16, 0.8); color: #f4e4c1; border: 1px solid #d4af37; border-radius: 4px; font-size: 0.7em;">
                        <option value="classic">☕ Classic Coffee</option>
                        <option value="vintage">🪵 Vintage Wood</option>
                        <option value="modern">🪟 Modern Glass</option>
                        <option value="gold">👑 Royal Gold</option>
                    </select>
                    <button class="btn" id="sound-toggle" onclick="toggleSound()" style="width: 100%; padding: 2px; font-size: 0.7em;">🔊 Sound ON</button>
                    <div style="display:flex; gap:6px; margin-top:4px;"></div>
                </div>
            </div>

            <!-- Center: Game Board -->
            <div class="board-container" style="
                display: flex;
                flex-direction: column;
                align-items: center;
                flex: 1;
                gap: 2px;
                padding: 0 5px;
                min-height: 0;
            ">
                <div class="board" id="board"></div>
                
                <!-- Winner Message & Claim Button -->
                <div id="winner-panel" style="
                    display: none;
                    background: linear-gradient(135deg, #2c5530, #4a7c59);
                    border: 2px solid #d4af37;
                    border-radius: 8px;
                    padding: 15px;
                    margin-top: 8px;
                    text-align: center;
                    max-width: 320px;
                    width: 100%;
                    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
                ">
                    <div id="winner-message" style="
                        color: #d4af37;
                        font-size: 2.4em;
                        font-weight: bold;
                        margin-bottom: 10px;
                    ">🎉 Congratulations! You Won!</div>
                    <button id="claim-reward-btn" onclick="completeGameAndClaim()" style="
                        background: linear-gradient(135deg, #4CAF50, #45a049);
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 10px;
                        font-size: 1.7em;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3), 0 2px 6px rgba(0, 0, 0, 0.15);
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        💰 Claim Your HUNGX Tokens
                    </button>
                </div>
            </div>

            <!-- Right Panel: Rooms & Info -->
            <div class="right-panel" style="
                display: flex;
                flex-direction: column;
                gap: 5px;
                min-width: 160px;
                max-width: 180px;
            ">
                <!-- Battle Info -->
                <div id="battle-info-display" style="
                    background: rgba(139, 69, 19, 0.2);
                    border: 1px solid rgba(212, 175, 55, 0.3);
                    border-radius: 8px;
                    padding: 8px;
                    font-size: 1.6em;
                ">
                    <div style="margin-bottom: 1px; color: #d4af37; font-weight: bold; font-size: 1em; text-align: center;">📊</div>
                    <div id="battle-queue-info" style="color: #f4e4c1; font-size: 1.5em;"></div>
                </div>

                <!-- Open Rooms - Enhanced -->
                <div id="rooms-panel" style="
                    background: linear-gradient(135deg, rgba(139, 69, 19, 0.3), rgba(160, 82, 45, 0.2));
                    border: 2px solid rgba(212, 175, 55, 0.4);
                    border-radius: 16px;
                    padding: 8px;
                    font-size: 0.8em;
                    backdrop-filter: blur(10px);
                    box-shadow: 
                        0 8px 20px rgba(0, 0, 0, 0.15),
                        0 4px 8px rgba(139, 69, 19, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
                    transition: all 0.3s ease;
                    flex: 2;
                ">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <span style="color: #d4af37; font-weight: bold; font-size: 1em;">🏠 Rooms</span>
                        <button class="btn" onclick="refreshRooms()" style="padding: 2px 4px; font-size: 0.7em;">🔄</button>
                    </div>
                    <div id="open-rooms-list" style="
                        display: flex;
                        flex-direction: column;
                        gap: 3px;
                        max-height: 200px;
                        overflow-y: auto;
                        min-height: 100px;
                    "></div>
                    <div id="no-rooms-message" style="
                        text-align: center;
                        color: #888;
                        font-size: 0.8em;
                        margin: 10px 0;
                        font-style: italic;
                    ">No active rooms</div>
                </div>

                <!-- Rules -->
                <div style="
                    background: rgba(139, 69, 19, 0.2);
                    border: 1px solid rgba(212, 175, 55, 0.3);
                    border-radius: 8px;
                    padding: 8px;
                ">
                    <button class="btn" onclick="showRules()" style="width: 100%; padding: 3px; font-size: 0.8em;">❓ Help</button>
                </div>
            </div>
        </div>

        <!-- Create Room Modal -->
        <div id="create-room-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center;" onclick="if(event.target === this) closeCreateRoomModal()">
            <div style="background: linear-gradient(135deg, #2c1810, #3d2817); border: 2px solid #d4af37; border-radius: 16px; padding: 20px; max-width: 400px; width: 90%; box-shadow: 0 20px 40px rgba(0,0,0,0.5);">
                <h3 style="text-align: center; color: #d4af37; margin-bottom: 15px;">🎯 Create New Room</h3>
                
                <div style="margin-bottom: 12px;">
                    <label style="display: block; color: #f4e4c1; margin-bottom: 5px; font-size: 0.9em;">💰 Stake Amount (HUNGX):</label>
                    <input type="number" id="room-stake-input" value="1000" min="100" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d4af37; background: #1a120c; color: #f4e4c1; font-size: 1em;" placeholder="Enter stake amount">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="btn" onclick="createRoomWithStake()" style="flex: 1; background: linear-gradient(135deg, #4CAF50, #45a049); padding: 12px; font-size: 1em;">🚀 Create Room</button>
                    <button class="btn" onclick="closeCreateRoomModal()" style="flex: 1; background: linear-gradient(135deg, #666, #555); padding: 12px; font-size: 1em;">❌ Cancel</button>
                </div>
            </div>
        </div>

        <!-- Join by ID Modal -->
        <div id="join-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; justify-content: center; align-items: center;" onclick="if(event.target === this) closeJoinModal()">
            <div style="background: linear-gradient(135deg, #2c1810, #3d2817); border: 2px solid #d4af37; border-radius: 16px; padding: 20px; max-width: 400px; width: 90%; box-shadow: 0 20px 40px rgba(0,0,0,0.5);">
                <h3 style="text-align: center; color: #d4af37; margin-bottom: 15px;">⚡ Join Room by ID</h3>
                
                <div style="margin-bottom: 12px;">
                    <label style="display: block; color: #f4e4c1; margin-bottom: 5px; font-size: 0.9em;">🎮 Game ID:</label>
                    <input type="text" id="join-game-id-input" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d4af37; background: #1a120c; color: #f4e4c1; font-size: 1em;" placeholder="Enter Game ID">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="btn" onclick="joinByGameId()" style="flex: 1; background: linear-gradient(135deg, #4CAF50, #45a049); padding: 12px; font-size: 1em;">⚡ Join Game</button>
                    <button class="btn" onclick="closeJoinModal()" style="flex: 1; background: linear-gradient(135deg, #666, #555); padding: 12px; font-size: 1em;">❌ Cancel</button>
                </div>
            </div>
        </div>

        <div id="game-over" class="game-over" style="
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: linear-gradient(135deg, #2c5530, #4a7c59);
            border: 3px solid #d4af37;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.6);
            min-width: 300px;
            text-align: center;
        ">
            <div class="winner" id="winner-text"></div>
            <button class="btn" onclick="newGame()">Play Again</button>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
    <script>
      // Force Socket.IO to use the correct server URL in production
      (function () {
        try {
          var params = new URLSearchParams(window.location.search);
          var forceLocal = params.get('useLocal') === '1';
          var isLocalHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
          var overrideSocket = params.get('socket');
          var SERVER_URL = overrideSocket || ((!forceLocal)
            ? 'https://chinesee.onrender.com'
            : 'http://localhost:3000');
          window.CHINESEE_SERVER_URL = SERVER_URL;
          try { console.log('📡 Socket target:', SERVER_URL); } catch (e) {}

          if (typeof window.io === 'function') {
            var REAL_IO = window.io;
            var patched = function (url, opts) {
              // If client passes undefined (same-origin) or nothing, force SERVER_URL
              var params = new URLSearchParams(window.location.search);
              var forceLocal = params.get('useLocal') === '1';
              var isLocalHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
              var isLocal = isLocalHost && forceLocal;
              if (typeof url === 'undefined' || url === null) {
                opts = opts || {};
                // Prefer pure websocket in production to avoid polling CORS issues
                // Use polling fallback too (both dev & prod), to improve proxy compatibility
                opts.transports = ['websocket', 'polling'];
                opts.upgrade = !forceRemote && isLocal;
                opts.path = '/socket.io';
                opts.withCredentials = false;
                var socket = REAL_IO(SERVER_URL, opts);
                // Fallback chain (dev only): 3000 -> 3001 -> remote
                if (isLocal && SERVER_URL.indexOf('http://localhost:3000') === 0) {
                  var stage = 0; // 0: try 3000, 1: 3001, 2: remote
                  function tryNext() {
                    if (socket.connected) return;
                    try {
                      if (stage === 0) {
                        stage = 1;
                        socket.io.uri = 'http://localhost:3001';
                        console.log('↪️ Falling back Socket.IO to http://localhost:3001');
                      } else if (stage === 1) {
                        stage = 2;
                        socket.io.uri = 'https://chinesee.onrender.com';
                        console.log('↪️ Falling back Socket.IO to https://chinesee.onrender.com');
                      } else {
                        return;
                      }
                      socket.io.opts.path = '/socket.io';
                      socket.io.opts.transports = ['websocket', 'polling'];
                      socket.io.disconnect();
                      socket.io.reconnect();
                    } catch (e) { /* noop */ }
                  }
                  var t1 = setTimeout(tryNext, 1200);
                  var t2;
                  var t3 = setTimeout(function(){ if (stage < 2) tryNext(); }, 3000);
                  socket.on('connect', function () { try { clearTimeout(t1); clearTimeout(t2); clearTimeout(t3); } catch (e) {} });
                  socket.on('connect_error', function () {
                    if (stage < 2) {
                      tryNext();
                      if (!t2) t2 = setTimeout(tryNext, 1800);
                    }
                  });
                }
                socket.on('connect_error', function (err) { try { console.warn('Socket connect_error:', err && (err.message || err)); } catch (e) {} });
                return socket;
              }
              // If dev URL leaked into prod call, override to SERVER_URL
              if (typeof url === 'string' && url.indexOf('http://localhost:3000') !== -1) {
                url = SERVER_URL;
              }
              // Ensure transports default
              opts = opts || {};
              if (!Array.isArray(opts.transports) || opts.transports.length === 0) {
                opts.transports = ['websocket', 'polling'];
              }
              if (typeof opts.upgrade === 'undefined') opts.upgrade = isLocal;
              if (!opts.path) opts.path = '/socket.io';
              opts.withCredentials = false;
              return REAL_IO(url, opts);
            };
            // Preserve Socket.IO static members
            try { Object.assign(patched, REAL_IO); } catch (e) {}
            window.io = patched;
          }
        } catch (e) {
          console.warn('Socket URL patch failed:', e);
        }
      })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="coffytokenvemodülabi.js"></script>
    <script>
    window.addEventListener('DOMContentLoaded', () => {
        // === SES SİSTEMİ ===
        class SoundManager {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.volume = 0.7;
                this.enabled = true;
                this.customBuffers = {}; // only 'move' custom supported
                this._pendingCustom = null;
                this.loadCustomAudioFromStorage();
                this.initializeAudioContext();
                this.createSounds();
            }
            
            async initializeAudioContext() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('🔊 Audio context initialized');
                    await this.decodePendingCustomBuffers();
                } catch (error) {
                    console.warn('Audio context failed:', error);
                }
            }
            
            createSounds() {
                // Default synthesized fallbacks (used if no custom audio provided)
                this.sounds = {
                    move: { freq: 440, duration: 0.07, type: 'sine' },
                    capture: { freq: 520, duration: 0.09, type: 'triangle' },
                    king: { freq: 680, duration: 0.12, type: 'sawtooth' },
                    win: { freq: 580, duration: 0.22, type: 'square' },
                    error: { freq: 200, duration: 0.12, type: 'sawtooth' },
                    notification: { freq: 660, duration: 0.12, type: 'sine' },
                    click: { freq: 330, duration: 0.04, type: 'triangle' },
                    steam: { freq: 800, duration: 0.25, type: 'sine' }
                };
            }

            loadCustomAudioFromStorage() {
                try {
                    const saved = localStorage.getItem('coffeeCheckers_custom_sounds');
                    if (!saved) return;
                    const map = JSON.parse(saved);
                    this._pendingCustom = map; // defer decoding until AudioContext ready
                } catch (_) {}
            }

            async decodePendingCustomBuffers() {
                if (!this._pendingCustom || !this.context) return;
                const entries = Object.entries(this._pendingCustom);
                for (const [name, b64] of entries) {
                    try {
                        const arrayBuff = Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
                        const audioBuffer = await this.context.decodeAudioData(arrayBuff.slice(0));
                        this.customBuffers[name] = audioBuffer;
                    } catch (e) {
                        console.warn('Failed to decode custom audio for', name, e);
                    }
                }
                this._pendingCustom = null;
            }
            
            async play(soundName) {
                if (!this.enabled || !this.context || !this.sounds[soundName]) {
                    console.log(`🔇 Sound ${soundName} skipped - not ready`);
                    return;
                }
                
                try {
                    if (this.context.state === 'suspended') {
                        await this.context.resume();
                        console.log('🔊 Audio context resumed');
                    }
                    
                    const custom = this.customBuffers[soundName];
                    if (custom) {
                        const src = this.context.createBufferSource();
                        const gain = this.context.createGain();
                        src.buffer = custom;
                        src.connect(gain);
                        gain.connect(this.context.destination);
                        gain.gain.value = this.volume;
                        src.start(0);
                    } else {
                        const sound = this.sounds[soundName];
                        const oscillator = this.context.createOscillator();
                        const gainNode = this.context.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        
                        oscillator.frequency.setValueAtTime(sound.freq, this.context.currentTime);
                        oscillator.type = sound.type;
                        
                        gainNode.gain.setValueAtTime(0, this.context.currentTime);
                        gainNode.gain.linearRampToValueAtTime(this.volume * 0.35, this.context.currentTime + 0.01);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + sound.duration);
                        
                        oscillator.start(this.context.currentTime);
                        oscillator.stop(this.context.currentTime + sound.duration);
                    }
                } catch (error) {
                    console.warn('Sound play failed:', error);
                }
            }
            
            playSequence(sequence, interval = 100) {
                sequence.forEach((soundName, index) => {
                    setTimeout(() => this.play(soundName), index * interval);
                });
            }
            
            setVolume(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
            }
            
            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        }
        
        // Global sound manager
        const soundManager = new SoundManager();
        
        // === TEMA VE ÖZELLEŞTİRME SİSTEMİ ===
        const THEME_VERSION = '2'; // bump this when changing default themes/models
        class ThemeManager {
            constructor() {
                this.themes = {
                    classic: {
                        name: 'Classic Coffee',
                        boardColors: { light: '#d4af37', dark: '#8b4513' },
                        pieces: { player1: '☕', player2: '🥛', king1: '👑', king2: '☕' },
                        background: 'linear-gradient(135deg, #2c1810, #4a2c20, #3d2817)'
                    },
                    vintage: {
                        name: 'Vintage Wood',
                        boardColors: { light: '#deb887', dark: '#8b7355' },
                        pieces: { player1: '♛', player2: '♜', king1: '♔', king2: '♚' },
                        background: 'linear-gradient(135deg, #3c2415, #5d3a1a, #4a2c20)'
                    },
                    modern: {
                        name: 'Modern Glass',
                        boardColors: { light: '#e8e8e8', dark: '#404040' },
                        pieces: { player1: '⚫', player2: '⚪', king1: '🔵', king2: '🔴' },
                        background: 'linear-gradient(135deg, #1a1a1a, #2d2d2d, #404040)'
                    },
                    gold: {
                        name: 'Royal Gold',
                        boardColors: { light: '#ffd700', dark: '#b8860b' },
                        pieces: { player1: '💰', player2: '💎', king1: '👑', king2: '💫' },
                        background: 'linear-gradient(135deg, #2c1a00, #4a2d00, #3d2400)'
                    }
                };
                this.currentTheme = 'classic';
                this.loadTheme();
            }
            
            setTheme(themeName) {
                if (this.themes[themeName]) {
                    this.currentTheme = themeName;
                    this.applyTheme(this.themes[themeName]);
                    this.saveTheme();
                    
                    // Force re-render if game exists
                    if (window.game && window.game.renderBoard) {
                        window.game.renderBoard();
                        console.log(`🎨 Theme applied and board re-rendered: ${themeName}`);
                    }
                    
                    soundManager.play('notification');
                    showStatus(`🎨 Theme changed to ${themeName}`, 'success', 2000);
                }
            }
            
            loadTheme() {
                try {
                    const savedVersion = localStorage.getItem('coffeeCheckers_theme_version');
                    if (savedVersion !== THEME_VERSION) {
                        // Invalidate old cached theme to reflect new models/colors
                        localStorage.removeItem('coffeeCheckers_theme');
                        localStorage.setItem('coffeeCheckers_theme_version', THEME_VERSION);
                    }
                } catch (_) {}

                const saved = localStorage.getItem('coffeeCheckers_theme');
                if (saved && this.themes[saved]) {
                    this.currentTheme = saved;
                }
                this.applyTheme();
            }
            
            saveTheme() {
                try {
                    localStorage.setItem('coffeeCheckers_theme', this.currentTheme);
                    localStorage.setItem('coffeeCheckers_theme_version', THEME_VERSION);
                } catch (_) {}
            }
            
            applyTheme(customTheme = null) {
                const theme = customTheme || this.themes[this.currentTheme];
                document.body.style.background = theme.background;
                
                // Update CSS variables
                document.documentElement.style.setProperty('--light-square', theme.boardColors.light);
                document.documentElement.style.setProperty('--dark-square', theme.boardColors.dark);
                
                // Re-render board immediately to ensure full theme application
                if (window.game && typeof window.game.renderBoard === 'function') {
                    window.game.renderBoard();
                }
                console.log(`🎨 Theme colors applied: light=${theme.boardColors.light}, dark=${theme.boardColors.dark}`);
            }
            
            getCurrentTheme() {
                return this.themes[this.currentTheme];
            }
        }
        
        // Global theme manager
        const themeManager = new ThemeManager();
        
        // === YAPAY ZEKA SİSTEMİ ===
        class CheckersAI {
            constructor(difficulty = 3) {
                this.difficulty = difficulty; // 1-5 zorluk seviyesi
                this.isActive = false;
                this.thinking = false;
            }
            
            activate() {
                this.isActive = true;
                console.log('🤖 AI activated');
            }
            
            deactivate() {
                this.isActive = false;
                this.thinking = false;
                console.log('🤖 AI deactivated');
            }
            
            async makeMove(game) {
                if (!this.isActive || this.thinking || game.gameOver) return false;
                
                this.thinking = true;
                soundManager.play('notification');
                
                // Show AI thinking indicator
                const statusElement = document.getElementById('current-turn');
                const originalText = statusElement?.textContent;
                if (statusElement) {
                    statusElement.textContent = '🤖 AI thinking...';
                    statusElement.style.animation = 'pulse 1s infinite';
                }
                
                // Simulate thinking delay
                await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000));
                
                const bestMove = this.getBestMove(game);
                
                if (bestMove) {
                    game.handleAIMove(bestMove.from, bestMove.to);
                    soundManager.play('move');
                }
                
                // Restore status
                if (statusElement) {
                    statusElement.textContent = originalText;
                    statusElement.style.animation = '';
                }
                
                this.thinking = false;
                return true;
            }
            
            getBestMove(game) {
                // CONTINUOUS CAPTURE CHECK: Eğer continuous capture modundaysa sadece o taşın yakalama hamlelerine bak
                if (game.continuousCapture && game.selectedPiece) {
                    const continuousMoves = game.validMoves.filter(move => move.isCapture);
                    if (continuousMoves.length > 0) {
                        console.log(`🔄 AI in continuous capture mode - ${continuousMoves.length} capture moves available`);
                        const selectedMove = continuousMoves[Math.floor(Math.random() * continuousMoves.length)];
                        return {
                            from: game.selectedPiece,
                            to: { row: selectedMove.row, col: selectedMove.col },
                            isCapture: true
                        };
                    }
                }
                
                // Normal hamle seçimi
                const allMoves = this.getAllPossibleMoves(game, 2); // AI is player 2
                if (allMoves.length === 0) return null;
                
                console.log(`🤖 AI analyzing ${allMoves.length} possible moves...`);
                
                // 1. Öncelik: Yakalama hamleleri (ZORUNLU)
                const captureMoves = allMoves.filter(move => move.isCapture);
                if (captureMoves.length > 0) {
                    console.log(`🎯 AI found ${captureMoves.length} capture moves - selecting one`);
                    return captureMoves[Math.floor(Math.random() * captureMoves.length)];
                }
                
                // 2. King promotion hamleleri
                const promotionMoves = allMoves.filter(move => {
                    const piece = game.board[move.from.row][move.from.col];
                    return !piece.isKing && move.to.row === 0; // AI pieces reach row 0 for promotion
                });
                
                if (promotionMoves.length > 0) {
                    console.log(`👑 AI found ${promotionMoves.length} promotion moves - prioritizing`);
                    return promotionMoves[Math.floor(Math.random() * promotionMoves.length)];
                }
                
                // 3. Merkeze yakın hamleler (stratejik pozisyon)
                const centerMoves = allMoves.filter(move => {
                    const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                    return centerDistance <= 2;
                });
                
                if (centerMoves.length > 0) {
                    console.log(`🎯 AI choosing center move from ${centerMoves.length} options`);
                    return centerMoves[Math.floor(Math.random() * centerMoves.length)];
                }
                
                // 4. Normal hamle
                console.log(`➡️ AI making normal move from ${allMoves.length} options`);
                return allMoves[Math.floor(Math.random() * allMoves.length)];
            }
            
            getAllPossibleMoves(game, player) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = game.board[row][col];
                        if (piece && piece.player === player) {
                            const pieceMoves = game.getValidMoves(row, col);
                            pieceMoves.forEach(move => {
                                moves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col },
                                    isCapture: move.isCapture
                                });
                            });
                        }
                    }
                }
                return moves;
            }
        }
        
        // Global AI instance
        const aiPlayer = new CheckersAI(3);
        
        // === QUICK MATCH SİSTEMİ ===
        class QuickMatchSystem {
            constructor() {
                this.matchmaking = false;
                this.currentStake = 0;
                this.waitingPlayers = new Map();
            }
            
            startQuickMatch(stakeAmount) {
                if (this.matchmaking) return false;
                
                this.matchmaking = true;
                this.currentStake = stakeAmount;
                
                // Send quick match request to server
                if (socket) {
                    socket.emit('quickMatch', { stake: stakeAmount, userAddress });
                    showStatus(`🔍 Quick matching for ${stakeAmount} stake...`, 'waiting');
                    soundManager.play('notification');
                }
                
                return true;
            }
            
            cancelQuickMatch() {
                if (!this.matchmaking) return;
                
                this.matchmaking = false;
                if (socket) {
                    socket.emit('cancelQuickMatch');
                }
                showStatus('❌ Quick match cancelled', 'error', 2000);
            }
            
            onMatchFound(matchData) {
                this.matchmaking = false;
                soundManager.playSequence(['notification', 'win'], 200);
                showStatus('🎯 Match found! Starting multiplayer game...', 'success', 3000);
                
                console.log('🎯 Quick match found:', matchData);
                
                // Join the matched room
                if (matchData.roomId) {
                    roomId = matchData.roomId;
                    playerNumber = matchData.playerNumber;
                    
                    // CRITICAL: AI'ı devre dışı bırak derhal
                    if (aiPlayer.isActive) {
                        aiPlayer.deactivate();
                        console.log('🤖 AI deactivated for multiplayer match');
                    }
                    
                    // Join room with callback to ensure success
                    socket.emit('joinRoom', roomId, (success) => {
                        if (success) {
                            console.log(`✅ Successfully joined room ${roomId} as Player ${playerNumber}`);
                            
                            // Reset game board for fresh multiplayer start
                            if (game) {
                                game.resetGame();
                                console.log('🔄 Game board reset for multiplayer');
                            } else {
                                game = new CoffeeCheckersRussian();
                                window.game = game;
                                console.log('🎮 New game instance created for multiplayer');
                            }
                            
                            // Enable multiplayer mode immediately
                            multiplayerReady = true;
                            console.log('🎮 Multiplayer mode activated');
                            
                            // Setup multiplayer synchronization
                            setupMultiplayerGameSync(game);
                            
                            // Request initial sync from server
                            socket.emit('requestSync');
                            
                            // Show multiplayer status
                            showStatus(`🎮 Multiplayer match started! You are Player ${playerNumber}`, 'success', 5000);
                            
                            // Save session
                            saveGameSession();
                            
                        } else {
                            console.error('❌ Failed to join matched room');
                            showStatus('❌ Failed to join match room', 'error', 3000);
                            this.matchmaking = false;
                        }
                    });
                }
            }
        }
        
        // Global quick match system
        const quickMatch = new QuickMatchSystem();
        
        // 1. Sınıf tanımı en başta
        class CoffeeCheckersRussian {
            constructor() {
                this.board = [];
                this.currentPlayer = 1;
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameOver = false;
                this.player1Score = 12;
                this.player2Score = 12;
                this.continuousCapture = false;
                this.captureSequence = [];
                this.initializeBoard();
                this.renderBoard();
                this.updateUI();
            }
            // Fully reset the game to initial state
            resetGame() {
                this.currentPlayer = 1;
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameOver = false;
                this.player1Score = 12;
                this.player2Score = 12;
                this.continuousCapture = false;
                this.captureSequence = [];
                this.initializeBoard();
                this.renderBoard();
                this.updateUI();
            }
            initializeBoard() {
                this.board = Array(8).fill().map(() => Array(8).fill(null));
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { player: 1, isKing: false };
                        }
                    }
                }
                for (let row = 5; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { player: 2, isKing: false };
                        }
                    }
                }
            }
            renderBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                const currentTheme = themeManager.getCurrentTheme();
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        
                        if (this.board[row][col]) {
                            const piece = document.createElement('div');
                            const pieceData = this.board[row][col];
                            piece.className = `piece player${pieceData.player}`;
                            
                            if (pieceData.isKing) {
                                piece.classList.add('king');
                                const kingEmoji = pieceData.player === 1 ? currentTheme.pieces.king1 : currentTheme.pieces.king2;
                                piece.innerHTML = `<span style="filter: drop-shadow(0 0 8px gold); font-size: 1.2em;">${kingEmoji}</span>`;
                            } else {
                                const regularEmoji = pieceData.player === 1 ? currentTheme.pieces.player1 : currentTheme.pieces.player2;
                                piece.innerHTML = `<span style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8)); text-shadow: 0 0 4px rgba(255,255,255,0.3);">${regularEmoji}</span>`;
                            }
                            
                            const steam = document.createElement('div');
                            steam.className = 'coffee-steam';
                            piece.appendChild(steam);
                            cell.appendChild(piece);
                        }
                        
                        if (this.selectedPiece && this.selectedPiece.row === row && this.selectedPiece.col === col) {
                            cell.classList.add('selected');
                        }
                        
                        const currentMove = this.validMoves.find(move => move.row === row && move.col === col);
                        if (currentMove) {
                            cell.classList.add(currentMove.isCapture ? 'must-capture' : 'valid-move');
                        }
                        
                        boardElement.appendChild(cell);
                    }
                }
            }
            handleCellClick(row, col) {
                if (this.gameOver) return;
                
                // Prevent any local moves before multiplayer match actually starts
                if (socket && roomId && !multiplayerReady) {
                    try { showStatus('⏳ Waiting for opponent to join...', 'waiting', 1500); } catch {}
                    return;
                }
                
                // SOLO AI MODE: Oyuncu sadece Player 1, AI Player 2
                if (!multiplayerReady && aiPlayer.isActive) {
                    if (this.currentPlayer !== 1) {
                        soundManager.play('error');
                        showStatus('🤖 AI\'s turn! Please wait...', 'waiting', 1500);
                        console.log(`❌ AI Mode: It's AI's turn (Player ${this.currentPlayer})!`);
                        return;
                    }
                    console.log(`✅ AI Mode: Your turn to move! (Player 1)`);
                }
                
                // Multiplayer kontrolü - Strict turn enforcement
                if (multiplayerReady) {
                    if (this.currentPlayer !== playerNumber) {
                        console.log(`❌ Not your turn! Current: ${this.currentPlayer}, You are: ${playerNumber}`);
                        return;
                    }
                    if (allowedPlayer && allowedPlayer !== this.currentPlayer) {
                        console.log(`❌ Player not allowed! Current: ${this.currentPlayer}, Allowed: ${allowedPlayer}`);
                        return;
                    }
                    console.log(`✅ Your turn to move! Player ${playerNumber}`);
                }
                
                const piece = this.board[row][col];
                
                if (this.selectedPiece) {
                    const validMove = this.validMoves.find(move => move.row === row && move.col === col);
                    if (validMove) {
                        this.makeMove(this.selectedPiece, validMove);
                        
                        // Multiplayer sync now handled by setupMultiplayerGameSync override
                        // No need for manual sendGameUpdate here
                        
                        // makeMove already handles continuous capture properly
                        // No need for duplicate logic here
                        
                        // makeMove already handles player switching, no need for manual switchPlayer()
                        
                        // Multiplayer sync now handled by setupMultiplayerGameSync override
                        // Turn notifications handled by the override system
                    } else {
                        if (!this.continuousCapture && piece && piece.player === this.currentPlayer) {
                            this.selectedPiece = { row, col };
                            this.validMoves = this.getValidMoves(row, col);
                        } else {
                            this.selectedPiece = null;
                            this.validMoves = [];
                        }
                    }
                } else if (piece && piece.player === this.currentPlayer) {
                    this.selectedPiece = { row, col };
                    this.validMoves = this.getValidMoves(row, col);
                }
                
                this.renderBoard();
                this.updateUI();
            }
            makeMove(from, to) {
                const piece = this.board[from.row][from.col];
                this.board[to.row][to.col] = piece;
                this.board[from.row][from.col] = null;
                
                // Ses efektleri
                if (to.isCapture) {
                    this.board[to.capturedRow][to.capturedCol] = null;
                    if (piece.player === 1) {
                        this.player2Score--;
                    } else {
                        this.player1Score--;
                    }
                    soundManager.play('capture');
                } else {
                    soundManager.play('move');
                }
                
                // King promotion
                if (!piece.isKing) {
                    if ((piece.player === 1 && to.row === 7) || (piece.player === 2 && to.row === 0)) {
                        piece.isKing = true;
                        soundManager.play('king');
                        setTimeout(() => soundManager.play('steam'), 300);
                    }
                }
                
                // TURN CONTROL: Her hamle sonrası sıra değişmeli
                const hadCapture = to.isCapture;
                
                // Continuous capture kontrolü - aynı taş ile yakalama devam edebilir mi?
                if (hadCapture) {
                    const nextCaptures = this.getValidMoves(to.row, to.col).filter(m => m.isCapture);
                    if (nextCaptures.length > 0) {
                        // Aynı taş ile yakalama devam edebilir - sıra değişmez
                        console.log(`🎯 Continuous capture available for ${piece.player}, sıra değişmez`);
                        this.continuousCapture = true;
                        this.selectedPiece = { row: to.row, col: to.col };
                        this.validMoves = nextCaptures;
                        this.renderBoard();
                        this.updateUI();
                        this.checkGameOver();
                        return; // Sıra değişmez!
                    }
                }
                
                // Normal hamle veya yakalama tamamlandı - sıra değişir
                this.continuousCapture = false;
                this.selectedPiece = null;
                this.validMoves = [];
                this.switchPlayer(); // Sıra değişimi
                
                this.renderBoard();
                this.updateUI();
                this.checkGameOver();
            }
            
            // AI hamlesi için özel method - STRICT RULES with CONTINUOUS CAPTURE
            handleAIMove(from, to) {
                // AI sadece kendi sırasında hareket edebilir
                if (this.currentPlayer !== 2) {
                    console.warn('❌ AI tried to move but it\'s not AI turn!');
                    return false;
                }
                
                // AI taşı kontrolü
                const piece = this.board[from.row][from.col];
                if (!piece || piece.player !== 2) {
                    console.warn('❌ AI tried to move invalid piece!');
                    return false;
                }
                
                // Valid move kontrolü
                const validMoves = this.getValidMoves(from.row, from.col);
                const move = validMoves.find(m => m.row === to.row && m.col === to.col);
                
                if (!move) {
                    console.warn('❌ AI tried to make invalid move!');
                    return false;
                }
                
                console.log(`🤖 AI making move: (${from.row},${from.col}) -> (${to.row},${to.col})`);
                
                // Hamleyi yap - makeMove kendi içinde sıra değişimini halleder
                this.makeMove(from, move);
                
                // CONTINUOUS CAPTURE CHECK: Eğer yakalama yapıldı ve devam edebilirse AI tekrar oynasın
                if (move.isCapture && this.continuousCapture && this.currentPlayer === 2) {
                    console.log('🔄 AI has continuous capture opportunity - will play again shortly...');
                    setTimeout(() => {
                        if (this.continuousCapture && this.currentPlayer === 2 && aiPlayer.isActive && !this.gameOver) {
                            console.log('🎯 AI continuing capture sequence...');
                            aiPlayer.makeMove(this);
                        }
                    }, 1200); // Biraz daha uzun bekle ki görsel olarak net olsun
                }
                
                return true;
            }
            switchPlayer() {
                const previousPlayer = this.currentPlayer;
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                
                console.log(`🔄 Turn switched: Player ${previousPlayer} -> Player ${this.currentPlayer}`);
                
                this.updateUI();
                
                // AI turn için kontrol (sadece solo modda)
                // Continuous capture durumunda AI zaten kendi içinde devam edecek
                if (this.currentPlayer === 2 && aiPlayer.isActive && !multiplayerReady && !this.gameOver && !this.continuousCapture) {
                    console.log('🤖 AI turn starting...');
                    setTimeout(() => {
                        if (this.currentPlayer === 2 && aiPlayer.isActive && !this.gameOver && !this.continuousCapture) {
                            aiPlayer.makeMove(this);
                        }
                    }, 1000);
                }
            }
            exportState() {
                return {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    player1Score: this.player1Score,
                    player2Score: this.player2Score,
                    gameOver: this.gameOver,
                    selectedPiece: null,
                    validMoves: [],
                    continuousCapture: false
                };
            }
            importState(state) {
                this.board = JSON.parse(JSON.stringify(state.board));
                this.currentPlayer = state.currentPlayer;
                this.player1Score = state.player1Score;
                this.player2Score = state.player2Score;
                this.gameOver = state.gameOver;
                this.selectedPiece = null;
                this.validMoves = [];
                this.continuousCapture = false;
                this.renderBoard();
                this.updateUI();
            }
            
            // Add missing getGameState and setGameState methods for multiplayer sync
            getGameState() {
                return this.exportState();
            }
            
            setGameState(state) {
                this.importState(state);
            }
            
            // Get current player as string for multiplayer
            getCurrentPlayer() {
                return this.currentPlayer === 1 ? 'player1' : 'player2';
            }
            checkGameOver() {
                if (this.player1Score === 0 || this.player2Score === 0) {
                    this.gameOver = true;
                    soundManager.playSequence(['capture', 'win'], 300);
                    
                    // AI'ı devre dışı bırak
                    if (aiPlayer.isActive) {
                        aiPlayer.deactivate();
                    }
                    
                    this.showGameOver();
                    return;
                }
                let hasValidMove = false;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.player === this.currentPlayer) {
                            const moves = this.getValidMoves(row, col);
                            if (moves.length > 0) {
                                hasValidMove = true;
                                break;
                            }
                        }
                    }
                    if (hasValidMove) break;
                }
                if (!hasValidMove) {
                    this.gameOver = true;
                    this.showGameOver();
                }
            }
            showGameOver() {
                const gameOverElement = document.getElementById('game-over');
                const winnerText = document.getElementById('winner-text');
                let winner;
                if (this.player1Score === 0) {
                    winner = '🥛 Latte';
                } else if (this.player2Score === 0) {
                    winner = '☕ Espresso';
                } else {
                    winner = this.currentPlayer === 1 ? '🥛 Latte' : '☕ Espresso';
                }
                winnerText.textContent = `${winner} Won!`;
                gameOverElement.style.display = 'block';
                
                // Kazanan oyuncuyu global olarak belirle
                let winnerPlayerNumber;
                if (this.player1Score === 0) {
                    winnerPlayerNumber = 2;
                } else if (this.player2Score === 0) {
                    winnerPlayerNumber = 1;
                } else {
                    winnerPlayerNumber = this.currentPlayer === 1 ? 2 : 1;
                }
                
                // Global winner'ı kaydet
                window.gameWinner = winnerPlayerNumber;
                console.log(`🏆 Game Over - Winner set to Player ${winnerPlayerNumber}`);
                
                // Battle modunda ödül butonunu aktif et
                if (currentBattleId) {
                    enableClaimButtonIfWinner();
                    
                    // Timer'ı durdur
                    if (timerInterval) {
                        clearInterval(timerInterval);
                        timerInterval = null;
                    }
                } else {
                    // Casual game için de claim butonunu aktif et
                    setTimeout(() => {
                        enableClaimButtonIfWinner();
                    }, 1500);
                }
            }
            updateUI() {
                document.getElementById('player1-score').textContent = this.player1Score;
                document.getElementById('player2-score').textContent = this.player2Score;
                const currentTurn = document.getElementById('current-turn');
                
                // Continuous capture durumunda özel gösterim
                if (this.continuousCapture) {
                    if (this.currentPlayer === 1) {
                        currentTurn.textContent = "🎯 MUST CAPTURE!";
                        currentTurn.style.color = '#ff4444';
                        currentTurn.style.fontWeight = 'bold';
                        currentTurn.style.animation = 'pulse 1s infinite';
                    } else {
                        currentTurn.textContent = "🤖 AI CAPTURING...";
                        currentTurn.style.color = '#ff8800';
                        currentTurn.style.fontWeight = 'bold';
                        currentTurn.style.animation = 'pulse 1s infinite';
                    }
                }
                // AI modunda daha net gösterim
                else if (!multiplayerReady && aiPlayer.isActive) {
                    if (this.currentPlayer === 1) {
                        currentTurn.textContent = "☕ Your Turn";
                        currentTurn.style.color = '#d4af37';
                        currentTurn.style.fontWeight = 'bold';
                        currentTurn.style.animation = '';
                    } else {
                        currentTurn.textContent = "🤖 AI Turn";
                        currentTurn.style.color = '#888';
                        currentTurn.style.fontWeight = 'normal';
                        currentTurn.style.animation = '';
                    }
                } else {
                    // Normal multiplayer veya solo mod
                    currentTurn.textContent = this.currentPlayer === 1 ? "☕ Turn" : "🥛 Turn";
                    currentTurn.style.color = '#f4e4c1';
                    currentTurn.style.fontWeight = 'normal';
                    currentTurn.style.animation = '';
                }
            }
            getValidMoves(row, col) {
                const piece = this.board[row][col];
                let moves = [];
                if (piece.isKing) {
                    moves = this.getKingMoves(row, col);
                } else {
                    moves = this.getRegularMoves(row, col);
                }
                if (!this.continuousCapture) {
                    let hasAnyCapture = false;
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const boardPiece = this.board[r][c];
                            if (boardPiece && boardPiece.player === this.currentPlayer) {
                                const pieceMoves = boardPiece.isKing ? this.getKingMoves(r, c) : this.getRegularMoves(r, c);
                                if (pieceMoves.some(move => move.isCapture)) {
                                    hasAnyCapture = true;
                                    break;
                                }
                            }
                        }
                        if (hasAnyCapture) break;
                    }
                    if (hasAnyCapture) {
                        return moves.filter(move => move.isCapture);
                    }
                }
                return moves;
            }
            getRegularMoves(row, col) {
                const piece = this.board[row][col];
                const moves = [];
                const forwardDirections = piece.player === 1 ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]];
                const allDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                for (const [dr, dc] of allDirections) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidPosition(newRow, newCol)) {
                        if (this.board[newRow][newCol] && this.board[newRow][newCol].player !== piece.player) {
                            const jumpRow = newRow + dr;
                            const jumpCol = newCol + dc;
                            if (this.isValidPosition(jumpRow, jumpCol) && !this.board[jumpRow][jumpCol]) {
                                moves.push({ 
                                    row: jumpRow, 
                                    col: jumpCol, 
                                    isCapture: true, 
                                    capturedRow: newRow, 
                                    capturedCol: newCol 
                                });
                            }
                        }
                    }
                }
                const captureMoves = moves.filter(move => move.isCapture);
                if (captureMoves.length > 0) {
                    return captureMoves;
                }
                for (const [dr, dc] of forwardDirections) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (this.isValidPosition(newRow, newCol) && !this.board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol, isCapture: false });
                    }
                }
                return moves;
            }
            getKingMoves(row, col) {
                const piece = this.board[row][col];
                const moves = [];
                const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                for (const [dr, dc] of directions) {
                    for (let i = 1; i < 8; i++) {
                        const newRow = row + (dr * i);
                        const newCol = col + (dc * i);
                        if (!this.isValidPosition(newRow, newCol)) break;
                        if (!this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, isCapture: false });
                        } else if (this.board[newRow][newCol].player !== piece.player) {
                            for (let j = i + 1; j < 8; j++) {
                                const jumpRow = row + (dr * j);
                                const jumpCol = col + (dc * j);
                                if (!this.isValidPosition(jumpRow, jumpCol)) break;
                                if (!this.board[jumpRow][jumpCol]) {
                                    moves.push({ 
                                        row: jumpRow, 
                                        col: jumpCol, 
                                        isCapture: true, 
                                        capturedRow: newRow, 
                                        capturedCol: newCol 
                                    });
                                } else {
                                    break;
                                }
                            }
                            break;
                        } else {
                            break;
                        }
                    }
                }
                const captureMoves = moves.filter(move => move.isCapture);
                if (captureMoves.length > 0) {
                    return captureMoves;
                }
                return moves;
            }
            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
        }

        // 2. Multiplayer değişkenleri ve fonksiyonlar
        let socket;
        let roomId = null;
        let playerNumber = null; // 1 veya 2
        let multiplayerReady = false;
        let game = null;
        
        // Game state persistence keys
        const GAME_STORAGE_KEY = 'coffeeCheckers_gameState';
        const SESSION_STORAGE_KEY = 'coffeeCheckers_session';
        
        // Winner panel management
        // Enhanced winner panel with board-overlay positioning
        function showWinnerPanel(isWinner) {
            const winnerPanel = document.getElementById('winner-panel');
            const winnerMessage = document.getElementById('winner-message');
            const claimBtn = document.getElementById('claim-reward-btn');
            const gameContainer = document.querySelector('.checkers-container') || document.querySelector('#game-container');
            
            console.log(`🎯 showWinnerPanel called: isWinner=${isWinner}, playerNumber=${playerNumber}, multiplayerReady=${multiplayerReady}`);
            
            if (!winnerPanel || !winnerMessage || !claimBtn) {
                console.warn('⚠️ Winner panel elements not found');
                return;
            }
            
            if (isWinner) {
                console.log('🏆 Winner panel: Showing CLAIM button for winner');
                winnerMessage.textContent = '🎉 Congratulations! You Won!';
                claimBtn.style.display = 'block';
                claimBtn.disabled = false;
                claimBtn.style.opacity = '1';
                
                // Prefer placing claim button just under the in-game winner text overlay
                const gameOverOverlay = document.getElementById('game-over');
                const winnerTextEl = document.getElementById('winner-text');
                if (gameOverOverlay && winnerTextEl) {
                    claimBtn.textContent = '🎉 CLAIM REWARD 🎉';
                    claimBtn.style.marginTop = '12px';
                    claimBtn.style.display = 'inline-block';
                    claimBtn.style.opacity = '1';
                    winnerTextEl.insertAdjacentElement('afterend', claimBtn);
                    console.log('🎯 Claim button placed under winner text in game-over overlay');
                } else if (winnerPanel) {
                    // Fallback: place inside winner panel under message
                    claimBtn.textContent = '🎉 CLAIM REWARD 🎉';
                    claimBtn.style.marginTop = '12px';
                    claimBtn.style.display = 'inline-block';
                    winnerPanel.appendChild(claimBtn);
                    console.log('🎯 Claim button placed inside winner panel');
                } else if (gameContainer) {
                    // Last fallback: overlay above the board
                    claimBtn.classList.add('board-overlay-claim');
                    claimBtn.textContent = '🎉 CLAIM REWARD 🎉';
                    gameContainer.style.position = 'relative';
                    claimBtn.style.position = 'absolute';
                    claimBtn.style.zIndex = '2000';
                    claimBtn.style.left = '50%';
                    claimBtn.style.transform = 'translateX(-50%)';
                    claimBtn.style.top = '10px';
                    gameContainer.appendChild(claimBtn);
                    console.log('🎯 Claim button positioned as overlay above board');
                }
                
                winnerPanel.style.display = 'block';
                
                // Add glow effect for winner
                winnerPanel.style.boxShadow = '0 0 20px rgba(212, 175, 55, 0.5)';
            } else {
                console.log('😔 Winner panel: Hiding claim button for loser');
                winnerMessage.textContent = '😔 Game Over - You Lost';
                claimBtn.style.display = 'none';
                winnerPanel.style.display = 'block';
                
                // Remove glow effect
                winnerPanel.style.boxShadow = 'none';
                
                // Auto-hide after 5 seconds for losers
                setTimeout(() => {
                    winnerPanel.style.display = 'none';
                }, 5000);
            }
        }
        
        // Hide winner panel
        function hideWinnerPanel() {
            const winnerPanel = document.getElementById('winner-panel');
            if (winnerPanel) {
                winnerPanel.style.display = 'none';
            }
        }
        
        // Toggle open rooms visibility
        function toggleOpenRooms() {
            const roomsList = document.getElementById('open-rooms-list');
            if (roomsList) {
                const isVisible = roomsList.style.display !== 'none';
                roomsList.style.display = isVisible ? 'none' : 'grid';
                if (!isVisible) {
                    refreshOpenRooms();
                }
            }
        }
        window.toggleOpenRooms = toggleOpenRooms;
        
        // Status notification system
        function showStatus(message, type = 'info', duration = 3000) {
            const banner = document.getElementById('game-status-banner');
            const statusText = document.getElementById('status-text');
            
            if (!banner || !statusText) return;
            
            // Set message and styling based on type
            statusText.textContent = message;
            banner.style.display = 'block';
            
            switch (type) {
                case 'success':
                    banner.style.background = 'linear-gradient(135deg, #2c5530, #4a7c59)';
                    banner.style.borderColor = '#4CAF50';
                    break;
                case 'error':
                    banner.style.background = 'linear-gradient(135deg, #5c2e2e, #7a3f3f)';
                    banner.style.borderColor = '#f44336';
                    break;
                case 'warning':
                    banner.style.background = 'linear-gradient(135deg, #5c4e2e, #7a673f)';
                    banner.style.borderColor = '#ff9800';
                    break;
                case 'waiting':
                    banner.style.background = 'linear-gradient(135deg, #2e3c5c, #3f4f7a)';
                    banner.style.borderColor = '#2196F3';
                    break;
                default: // info
                    banner.style.background = 'linear-gradient(135deg, #2c5530, #4a7c59)';
                    banner.style.borderColor = '#d4af37';
            }
            
            // Auto-hide after duration
            if (duration > 0) {
                setTimeout(() => {
                    banner.style.display = 'none';
                }, duration);
            }
        }
        
        // Save game session to localStorage
        function saveGameSession() {
            if (!roomId || !currentGameId) return;
            
            const sessionData = {
                roomId,
                playerNumber,
                currentGameId,
                multiplayerReady,
                userAddress,
                currentWalletType,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(sessionData));
                console.log('💾 Game session saved:', sessionData);
            } catch (e) {
                console.warn('Failed to save session:', e);
            }
        }
        
        // Save game state to localStorage
        function saveGameState() {
            if (!game || !multiplayerReady) return;
            
            const gameData = {
                gameState: game.exportState(),
                roomId,
                playerNumber,
                currentGameId,
                timestamp: Date.now()
            };
            
            try {
                localStorage.setItem(GAME_STORAGE_KEY, JSON.stringify(gameData));
                console.log('🎮 Game state saved');
            } catch (e) {
                console.warn('Failed to save game state:', e);
            }
        }
        
        // Load and restore game session
        function restoreGameSession() {
            try {
                const sessionStr = localStorage.getItem(SESSION_STORAGE_KEY);
                if (!sessionStr) return null;
                
                const sessionData = JSON.parse(sessionStr);
                
                // Check if session is recent (within 2 hours)
                const maxAge = 2 * 60 * 60 * 1000; // 2 hours
                if (Date.now() - sessionData.timestamp > maxAge) {
                    localStorage.removeItem(SESSION_STORAGE_KEY);
                    localStorage.removeItem(GAME_STORAGE_KEY);
                    console.log('🕒 Session expired, cleared');
                    return null;
                }
                
                console.log('📥 Restoring session:', sessionData);
                return sessionData;
            } catch (e) {
                console.warn('Failed to restore session:', e);
                return null;
            }
        }
        
        // Load game state from localStorage
        function restoreGameState() {
            try {
                const gameStr = localStorage.getItem(GAME_STORAGE_KEY);
                if (!gameStr) return null;
                
                const gameData = JSON.parse(gameStr);
                console.log('🎮 Restoring game state:', gameData);
                return gameData;
            } catch (e) {
                console.warn('Failed to restore game state:', e);
                return null;
            }
        }
        
        // Clear saved data when game ends
        function clearGameData() {
            localStorage.removeItem(GAME_STORAGE_KEY);
            localStorage.removeItem(SESSION_STORAGE_KEY);
            console.log('🗑️ Game data cleared');
        }

        function showRoomSelection() {
            const modalDiv = document.createElement('div');
            modalDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 2000;`;
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                color: #f4e4c1; padding: 30px; border-radius: 15px;
                border: 2px solid #d4af37; max-width: 400px;
                box-shadow: 0 15px 35px rgba(0,0,0,0.5);`;
            contentDiv.innerHTML = `
                <h2>Multiplayer Room</h2>
                <button id="createRoomBtn" class="btn">Create Room</button>
                <br><br>
                <input id="joinGameIdInput" placeholder="Game ID" style="padding:8px; border-radius:5px; border:1px solid #d4af37;">
                <button id="joinRoomBtn" class="btn">Join by Game ID</button>
                <br><br>
                <button id="listRoomsBtn" class="btn">List Open Rooms</button>
                <div id="openRoomsList" style="margin-top:10px;"></div>
                <div id="roomStatus"></div>
            `;
            modalDiv.appendChild(contentDiv);
            document.body.appendChild(modalDiv);
            document.getElementById('createRoomBtn').onclick = () => {
                const emitCreateRoom = () => socket.emit('createRoom', (id) => {
                    roomId = id;
                    playerNumber = 1;
                    document.getElementById('roomStatus').innerHTML = `Room created! Code: <b>${roomId}</b><br>Waiting for opponent...`;
                });
                if (!socket || !socket.connected) {
                    console.log('⏳ Waiting for socket connection to create room (modal)...');
                    socket.once('connect', () => emitCreateRoom());
                    setTimeout(() => { if (socket && socket.connected && !roomId) emitCreateRoom(); }, 1500);
                } else {
                    emitCreateRoom();
                }
            };
            document.getElementById('joinRoomBtn').onclick = () => {
                const gid = document.getElementById('joinGameIdInput').value.trim();
                if (!gid || isNaN(gid)) {
                    document.getElementById('roomStatus').innerHTML = 'Enter a valid Game ID!';
                    return;
                }
                // Find a waiting room with this gameId from server
                socket.emit('listRooms', (openRooms) => {
                    const target = (openRooms || []).find(r => r.meta && String(r.meta.gameId) === String(gid));
                    if (!target) {
                        document.getElementById('roomStatus').innerHTML = 'No waiting room for this Game ID.';
                        return;
                    }
                    socket.emit('joinRoom', target.roomId, (success) => {
                        if (success) {
                            roomId = target.roomId;
                            playerNumber = 2;
                            document.getElementById('roomStatus').innerHTML = `Joined! Starting...`;
                    } else {
                            document.getElementById('roomStatus').innerHTML = 'Room not found or full!';
                        }
                    });
                });
            };
            document.getElementById('listRoomsBtn').onclick = () => {
                socket.emit('listRooms', (openRooms) => {
                    const listDiv = document.getElementById('openRoomsList');
                    if (openRooms.length === 0) {
                        listDiv.innerHTML = '<i>No open rooms.</i>';
                        return;
                    }
                    listDiv.innerHTML = openRooms.map(r => `<button class='btn' style='margin:2px;' data-room='${r.roomId}'>${r.roomId}</button>`).join(' ');
                    // Butonlara tıklama ile katılma
                    openRooms.forEach(r => {
                        const btn = listDiv.querySelector(`[data-room='${r.roomId}']`);
                        btn.onclick = () => {
                            socket.emit('joinRoom', r.roomId, (success) => {
                                if (success) {
                                    roomId = r.roomId;
                                    playerNumber = 2;
                                    document.getElementById('roomStatus').innerHTML = `Joined room! Starting...`;
                                } else {
                                    document.getElementById('roomStatus').innerHTML = 'Room not found or full!';
                                }
                            });
                        };
                    });
                });
            };
            socket.on('startGame', (gameData) => {
                console.log('🎮 Enhanced startGame received:', gameData);
                
                if (gameData && gameData.freshStart) {
                    console.log('🔄 Fresh multiplayer game starting - resetting board');
                    // Force fresh game state for both players
                    game = new CoffeeCheckersRussian();
                    game.resetGame();
                } else if (!game) {
                    game = new CoffeeCheckersRussian();
                }
                
                multiplayerReady = true;
                modalDiv.remove();
                
                // Start synchronized multiplayer game
                startBoardAndTimer();
                setupMultiplayerGameSync(game);

                // Immediately request authoritative sync from server
                if (socket && roomId) {
                    console.log('🔁 Requesting authoritative sync from server...');
                    socket.emit('requestSync');
                }
                
                // Show multiplayer status
                showStatus(`🎮 Multiplayer game started! You are Player ${playerNumber}`, 'success', 4000);
            });
            socket.on('playerLeft', () => {
                alert('Opponent left. Game ended.');
                window.location.reload();
            });
        }
        function startMultiplayer() {
            if (!socket) socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
            // Auto-join if invite params exist
            const params = new URLSearchParams(window.location.search);
            const r = params.get('room');
            const gid = params.get('gameId');
            if (r && r.length === 6) {
                socket.emit('joinRoom', r.toUpperCase(), (success) => {
                    if (success) {
                        roomId = r.toUpperCase();
                        if (gid && !isNaN(gid)) currentGameId = gid;
                        playerNumber = 2;
            socket.on('startGame', (gameData) => {
                console.log('🚀 Enhanced startGame event received:', gameData);
                
                if (gameData && gameData.freshStart) {
                    console.log('🔄 Fresh multiplayer game starting - resetting board');
                    game = new CoffeeCheckersRussian();
                    game.resetGame();
                } else if (!game) {
                    game = new CoffeeCheckersRussian();
                    console.log('🎯 Game instance created for startGame');
                }
                
                startBoardAndTimer();
                multiplayerReady = true;
                setupMultiplayerGameSync(game);
                
                // Show game start notification
                showStatus(`🚀 Synchronized game started! You are Player ${playerNumber}`, 'success', 3000);
                
                // Oyun başlarken sıra bilgisini belirgin göster
                const currentTurn = document.getElementById('current-turn');
                    if (currentTurn) currentTurn.textContent = "☕ Turn";
                
                console.log('✅ Game synchronized and ready for both players');
                
                // Save session when game starts
                saveGameSession();
            });
                    } else {
            showRoomSelection();
                    }
                });
            } else {
                showRoomSelection();
            }
        }
        function sendGameUpdate(gameState) {
            if (multiplayerReady && roomId && socket) {
                console.log('📤 Sending game update:', { roomId, currentPlayer: gameState.currentPlayer, scores: [gameState.player1Score, gameState.player2Score] });
                socket.emit('updateGame', roomId, gameState);
                
                // Auto-save game state after each move
                saveGameState();
            } else {
                console.warn('⚠️ Cannot send game update:', { multiplayerReady, roomId, socket: !!socket });
            }
        }
        function setupMultiplayerGameSync(game) {
            if (!socket || !game) {
                console.error('❌ No socket or game for sync');
                return;
            }
            
            console.log('🔗 Setting up enhanced multiplayer game sync with turn validation');
            socket.off('gameUpdate'); // Remove old listeners
            socket.off('opponentMove'); 
            socket.off('gameEnded');
            
            // Override handleCellClick to intercept moves for multiplayer
            const originalHandleCellClick = game.handleCellClick.bind(game);
            game.handleCellClick = function(row, col) {
                console.log(`🎯 Player ${playerNumber} clicking cell: (${row},${col})`);
                
                // Check if it's current player's turn
                const currentTurn = game.getCurrentPlayer();
                const isMyTurn = (playerNumber === 1 && currentTurn === 'player1') || 
                                (playerNumber === 2 && currentTurn === 'player2');
                
                if (!isMyTurn) {
                    console.log('❌ Not your turn!');
                    showStatus('❌ Wait for your turn!', 'error', 1500);
                    return;
                }
                
                // Store state before move
                const stateBefore = JSON.stringify(game.getGameState());
                
                // Execute the original click logic
                originalHandleCellClick(row, col);
                
                // Check if state actually changed (move was made)
                const stateAfter = JSON.stringify(game.getGameState());
                if (stateBefore !== stateAfter && socket && multiplayerReady) {
                    console.log('📡 Sending authoritative game update...');
                    
                    // Send complete game state update for synchronization
                    socket.emit('updateGame', roomId, game.getGameState());
                    
                    // Also send individual move for real-time feedback
                    socket.emit('makeMove', {
                        gameState: game.getGameState(),
                        playerNumber: playerNumber,
                        gameId: currentGameId,
                        roomId: roomId,
                        clickedCell: { row, col },
                        timestamp: Date.now()
                    });
                    
                    // Update turn display
                    const currentPlayerEl = document.querySelector('.current-player');
                    if (currentPlayerEl) {
                        const newTurn = game.getCurrentPlayer();
                        const isMyNewTurn = (playerNumber === 1 && newTurn === 'player1') || 
                                           (playerNumber === 2 && newTurn === 'player2');
                        currentPlayerEl.textContent = isMyNewTurn ? '☕ Your Turn' : '🥛 Opponent\'s Turn';
                    }
                    
                    showStatus('✅ Move sent!', 'success', 1000);
                    console.log('📡 Move sent successfully to room:', roomId);
                }
            };
            
            // Handle authoritative game state updates from server  
            socket.on('gameUpdate', (payload) => {
                // Accept both flat authoritative objects and wrapped objects
                const data = payload || {};
                const state = data.gameState || data; // if server sends flat state
                const fromPlayer = data.playerNumber;

                console.log('📥 Received game update:', {
                    flat: !data.gameState,
                    currentPlayer: state.currentPlayer,
                    scores: [state.player1Score, state.player2Score],
                    fromPlayer
                });

                // Ignore our own echo when playerNumber is present
                if (fromPlayer && fromPlayer === playerNumber) {
                    console.log('↩️ Ignoring echo of our own update');
                    return;
                }

                if (state && typeof state === 'object' && (state.board || state.currentPlayer)) {
                    game.importState(state);
                    game.renderBoard();
                    game.updateUI();
                    saveGameState();

                    const isMyTurn = (game.currentPlayer === playerNumber);
                    if (isMyTurn) {
                        showStatus('✅ Your turn!', 'success', 1500);
                    } else {
                        showStatus(`⏳ Player ${game.currentPlayer}'s turn`, 'info', 1500);
                    }
                } else {
                    console.warn('⚠️ Invalid gameUpdate payload ignored:', payload);
                }
            });
            
            // Handle individual moves from opponent
            socket.on('opponentMove', (moveData) => {
                console.log('📨 Received opponent move:', moveData);
                
                if (moveData.gameState && moveData.gameId === currentGameId) {
                    // Apply the complete game state from opponent
                    console.log('🔄 Applying opponent game state...');
                    game.setGameState(moveData.gameState);
                    
                    // Force UI update
                    game.renderBoard();
                    game.updateUI();
                    
                    // Update turn display
                    const currentPlayerEl = document.querySelector('.current-player');
                    if (currentPlayerEl) {
                        const currentTurn = game.getCurrentPlayer();
                        const isMyTurn = (playerNumber === 1 && currentTurn === 'player1') || 
                                        (playerNumber === 2 && currentTurn === 'player2');
                        currentPlayerEl.textContent = isMyTurn ? '☕ Your Turn' : '🥛 Opponent\'s Turn';
                        console.log(`🔄 Turn updated: ${currentPlayerEl.textContent}`);
                    }
                    
                    showStatus('📨 Opponent moved!', 'info', 1500);
                    console.log('♻️ Game state synchronized with opponent');
                    saveGameState(); // Save synchronized state
                    
                    // Check for winner after opponent move
                    setTimeout(() => {
                        if (game && game.checkGameOver) {
                            game.checkGameOver();
                        }
                    }, 500);
                }
            });
            
            // Handle game completion
            socket.on('gameEnded', async (data) => {
                console.log('🏁 Game ended:', data);
                if (data.winner) {
                    // Prefer server-sent gameId; fallback to currentGameId
                    if (!currentGameId && data.gameId) currentGameId = data.gameId;
                    const isWinner = (playerNumber === 1 && data.winner === 'player1') || 
                                    (playerNumber === 2 && data.winner === 'player2');
                    
                    if (isWinner) {
                        showStatus('🎉 You won! Claim button enabled!', 'success', 5000);
                        if (currentGameId) updateGameIdDisplay(currentGameId, 'completed');
                        showWinnerPanel(true); // Show claim button
                        // Optional auto-complete only once
                        if (!onchainGame.completed) {
                            try {
                                if (typeof moduleContract.completeMultiplayerGame === 'function') {
                                    const tx = await moduleContract.completeMultiplayerGame(currentGameId, { gasLimit: 350000 });
                                    await tx.wait();
                                    onchainGame.completed = true;
                                } else if (currentGameId && userAddress) {
                                    const tx1 = await moduleContract.completeGame(currentGameId, userAddress, { gasLimit: 300000 });
                                    await tx1.wait();
                                    onchainGame.completed = true;
                                }
                            } catch (e) {
                                console.warn('completeGame/completeMultiplayerGame auto-call failed or unavailable:', e?.reason || e?.message || e);
                            }
                        }
                    } else {
                        showStatus('😔 You lost. Better luck next time!', 'error', 3000);
                        if (currentGameId) updateGameIdDisplay(currentGameId, 'completed');
                        showWinnerPanel(false); // Hide claim button
                    }
                }
            });
            
            console.log('✅ Enhanced multiplayer synchronization setup complete');
        }
        function newGame(multiplayer = false) {
            document.getElementById('game-over').style.display = 'none';
            
            // AI'ı devre dışı bırak
            aiPlayer.deactivate();
            
            game = new CoffeeCheckersRussian();
            window.game = game; // Global erişim için
            
            if (multiplayer) {
                setupMultiplayerGameSync(game);
                console.log('🔄 Multiplayer game started, AI disabled');
            } else {
                // Solo modda AI'ı aktifleştir
                setTimeout(() => {
                    aiPlayer.activate();
                    console.log('🤖 Solo mode: AI activated');
                }, 1000);
            }
            
            soundManager.play('notification');
        }
        window.newGame = newGame;
        function showRules() {
            const modalDiv = document.createElement('div');
            modalDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 2000;`;
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                color: #f4e4c1; padding: 30px; border-radius: 15px;
                border: 2px solid #d4af37; max-width: 600px;
                box-shadow: 0 15px 35px rgba(0,0,0,0.5);`;
            contentDiv.innerHTML = `
                <h2>Rules</h2>
                <p>Coffee Checkers is a coffee-themed Russian Checkers game played on an 8x8 board.</p>
                <h3>Pieces & Moves</h3>
                <ul>
                    <li>☕ Espresso: Player 1</li>
                    <li>🥛 Latte: Player 2</li>
                </ul>
                <p>Pieces move diagonally; captures are mandatory when available. Repeated captures are allowed.</p>
                <h3>King</h3>
                <p>Reaching the far row crowns a piece as King; it moves both forward and backward.</p>
                <h3>Game End</h3>
                <p>Game ends when a player has no moves or no pieces left. Remaining pieces decide the winner.</p>
                <button class="btn" onclick="closeRules()">Close</button>
            `;
            modalDiv.appendChild(contentDiv);
            document.body.appendChild(modalDiv);
            function closeRules() {
                modalDiv.remove();
            }
            window.closeRules = closeRules;
        }
        window.showRules = showRules;
        // Modern UI için CSS'i doğrudan HTML'de bırak veya klasik string olarak ekle:
        const style = document.createElement('style');
        style.textContent = `
.side-panel {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 90px;
    min-width: 90px;
    gap: 30px;
}
.turn-indicator {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2em;
    font-weight: bold;
    margin-bottom: 20px;
    box-shadow: 0 0 20px 5px #d4af37;
    background: linear-gradient(135deg, #d4af37 60%, #fffbe6 100%);
    animation: turnPulse 1.2s infinite;
}
@keyframes turnPulse {
    0%, 100% { box-shadow: 0 0 20px 5px #d4af37; }
    50% { box-shadow: 0 0 40px 15px #ffe066; }
}
.side-player {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    font-size: 1.1em;
    font-weight: bold;
    color: #d4af37;
    text-shadow: 1px 1px 4px #2c1810;
}
.side-score {
    font-size: 1.5em;
    color: #fffbe6;
}
.main-board-row {
    display: flex;
    flex-direction: row;
    align-items: stretch;
}
.main-board-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}`;
document.head.appendChild(style);

        // Multi-Wallet Connection System
        let provider, signer, coffyToken, moduleContract, userAddress;
        // Import HUNGX token address/ABI and module from external file
        // These are declared in coffytokenvemodülabi.js
        // On-chain game state guard to prevent duplicate txs
        let onchainGame = { completed: false, claimed: false };
        let currentWalletType = null;
        let walletConnections = new Map(); // Store multiple wallet connections
        
        // Wallet types
        const WALLET_TYPES = {
            METAMASK: 'metamask',
            WALLETCONNECT: 'walletconnect',
            COINBASE: 'coinbase',
            TRUST: 'trust'
        };

        // Detect available wallets
        function detectAvailableWallets() {
            const wallets = [];
            
            if (window.ethereum) {
                if (window.ethereum.isMetaMask) {
                    wallets.push({ type: WALLET_TYPES.METAMASK, name: 'MetaMask', icon: '🦊' });
                }
                if (window.ethereum.isCoinbaseWallet) {
                    wallets.push({ type: WALLET_TYPES.COINBASE, name: 'Coinbase Wallet', icon: '🔵' });
                }
                if (window.ethereum.isTrust) {
                    wallets.push({ type: WALLET_TYPES.TRUST, name: 'Trust Wallet', icon: '🛡️' });
                }
                if (!window.ethereum.isMetaMask && !window.ethereum.isCoinbaseWallet && !window.ethereum.isTrust) {
                    wallets.push({ type: WALLET_TYPES.METAMASK, name: 'Web3 Wallet', icon: '💼' });
                }
            }
            
            return wallets;
        }

        // Show wallet selection modal
        function showWalletSelection() {
            const wallets = detectAvailableWallets();
            
            if (wallets.length === 0) {
                alert('No Web3 wallet found! Please install MetaMask or a compatible wallet.');
                return;
            }

            const modalDiv = document.createElement('div');
            modalDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 3000;`;
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                color: #f4e4c1; padding: 30px; border-radius: 15px;
                border: 2px solid #d4af37; max-width: 400px; width: 90%;
                box-shadow: 0 15px 35px rgba(0,0,0,0.5);`;
            
            let walletsHTML = '<h2 style="text-align: center; margin-bottom: 20px;">Select Wallet</h2>';
            wallets.forEach(wallet => {
                walletsHTML += `
                    <button class="btn wallet-select-btn" data-wallet="${wallet.type}"
                            style="width: 100%; margin: 10px 0; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span style="font-size: 3em;">${wallet.icon}</span>
                        <span>${wallet.name}</span>
                    </button>`;
            });
            
            walletsHTML += `
                <button class="btn" onclick="closeWalletModal()"
                        style="width: 100%; margin-top: 20px; background: #666;">
                    Cancel
                </button>`;
            
            contentDiv.innerHTML = walletsHTML;
            modalDiv.appendChild(contentDiv);
            document.body.appendChild(modalDiv);
            
            // Add event listeners
            contentDiv.querySelectorAll('.wallet-select-btn').forEach(btn => {
                btn.onclick = () => connectSpecificWallet(btn.dataset.wallet, modalDiv);
            });
            
            window.closeWalletModal = () => modalDiv.remove();
        }

        // Connect to specific wallet
        async function connectSpecificWallet(walletType, modal) {
            try {
                let targetProvider = null;
                
                switch (walletType) {
                    case WALLET_TYPES.METAMASK:
                        if (window.ethereum && window.ethereum.isMetaMask) {
                            targetProvider = window.ethereum;
                        } else if (window.ethereum) {
                            targetProvider = window.ethereum;
                        }
                        break;
                    case WALLET_TYPES.COINBASE:
                        if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                            targetProvider = window.ethereum;
                        }
                        break;
                    case WALLET_TYPES.TRUST:
                        if (window.ethereum && window.ethereum.isTrust) {
                            targetProvider = window.ethereum;
                        }
                        break;
                }
                
                if (!targetProvider) {
                    alert('Selected wallet not found!');
                    return;
                }
                
                provider = new ethers.providers.Web3Provider(targetProvider, 'any');
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                userAddress = await signer.getAddress();
                currentWalletType = walletType;
                
                // Store connection info
                walletConnections.set(userAddress, {
                    type: walletType,
                    provider: provider,
                    signer: signer,
                    address: userAddress
                });
                
                coffyToken = new ethers.Contract(coffytokenAddress, coffytokenAbi, signer);
                moduleContract = new ethers.Contract(moduleAddress, moduleAbi, signer);
                
                // Update UI
                updateWalletUI();
                modal.remove();
                
                console.log(`Connected to ${walletType} wallet:`, userAddress);
                
                // React to network/account changes
                if (targetProvider && typeof targetProvider.on === 'function') {
                    const reinitWeb3 = async () => {
                        try {
                            provider = new ethers.providers.Web3Provider(targetProvider, 'any');
                            signer = provider.getSigner();
                            userAddress = await signer.getAddress();
                            coffyToken = new ethers.Contract(coffytokenAddress, coffytokenAbi, signer);
                            moduleContract = new ethers.Contract(moduleAddress, moduleAbi, signer);
                            updateWalletUI();
                            console.log('Web3 reinitialized after network/account change');
                        } catch (e) {
                            console.warn('Reinit failed:', e);
                        }
                    };
                    targetProvider.removeListener && targetProvider.removeListener('chainChanged', reinitWeb3);
                    targetProvider.on('chainChanged', reinitWeb3);
                    targetProvider.removeListener && targetProvider.removeListener('accountsChanged', reinitWeb3);
                    targetProvider.on('accountsChanged', reinitWeb3);
                }
                
            } catch (error) {
                console.error('Wallet connection failed:', error);
                alert('Wallet connection failed: ' + error.message);
            }
        }

        // Update wallet UI
        function updateWalletUI() {
            const walletAddressEl = document.getElementById('wallet-address');
            const connectBtnEl = document.getElementById('connect-btn');
            
            if (walletAddressEl && userAddress) {
                const walletInfo = walletConnections.get(userAddress);
                const walletIcon = getWalletIcon(walletInfo?.type);
                walletAddressEl.innerHTML = `${walletIcon} ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                walletAddressEl.style.display = 'block';
            }
            
            if (connectBtnEl) {
                connectBtnEl.style.display = 'none';
            }
        }

        // Get wallet icon
        function getWalletIcon(walletType) {
            switch (walletType) {
                case WALLET_TYPES.METAMASK: return '🦊';
                case WALLET_TYPES.COINBASE: return '🔵';
                case WALLET_TYPES.TRUST: return '🛡️';
                default: return '💼';
            }
        }

        // Legacy connect wallet function (updated)
        async function connectWallet() {
            showWalletSelection();
        }

        // Attempt to silently reconnect to previously connected wallet
        async function autoReconnectWalletIfPossible() {
            try {
                if (coffyToken && moduleContract && userAddress) return true;
                const eth = window.ethereum;
                if (!eth) return false;
                const web3Prov = new ethers.providers.Web3Provider(eth, 'any');
                // Do NOT prompt; only read existing permissions
                const accounts = await web3Prov.send('eth_accounts', []);
                if (!accounts || accounts.length === 0) return false;
                provider = web3Prov;
                signer = provider.getSigner();
                userAddress = accounts[0];
                coffyToken = new ethers.Contract(coffytokenAddress, coffytokenAbi, signer);
                moduleContract = new ethers.Contract(moduleAddress, moduleAbi, signer);
                // Track connection
                walletConnections.set(userAddress, {
                    type: currentWalletType || (eth.isMetaMask ? WALLET_TYPES.METAMASK : 'web3'),
                    provider,
                    signer,
                    address: userAddress
                });
                updateWalletUI();
                // Attach listeners
                const reinitWeb3 = async () => {
                    try {
                        provider = new ethers.providers.Web3Provider(eth, 'any');
                        signer = provider.getSigner();
                        userAddress = await signer.getAddress();
                        coffyToken = new ethers.Contract(coffytokenAddress, coffytokenAbi, signer);
                        moduleContract = new ethers.Contract(moduleAddress, moduleAbi, signer);
                        updateWalletUI();
                    } catch (_) {}
                };
                eth.removeListener && eth.removeListener('chainChanged', reinitWeb3);
                eth.on && eth.on('chainChanged', reinitWeb3);
                eth.removeListener && eth.removeListener('accountsChanged', reinitWeb3);
                eth.on && eth.on('accountsChanged', reinitWeb3);
                return true;
            } catch (_) {
                return false;
            }
        }

        async function ensureWalletReady() {
            if (!coffyToken || !userAddress || !moduleContract) {
                const ok = await autoReconnectWalletIfPossible();
                if (!ok) return false;
            }
            try {
                await ensureCorrectNetworkAndContracts();
            } catch (_) {
                // ignore here; caller will surface if needed
            }
            return !!(coffyToken && userAddress && moduleContract);
        }

        // Approve ve battle akışı
        const MaxUint256 = ethers.constants ? ethers.constants.MaxUint256 : '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

        // Ensure wallet on correct network (Base Mainnet) and contracts exist
        async function ensureCorrectNetworkAndContracts() {
            if (!provider) throw new Error('Provider not ready - please reconnect your wallet');
            
            console.log('🔍 Checking current network...');
            const network = await provider.getNetwork();
            const desiredChainId = 8453; // Base Mainnet
            console.log(`Current network: ${network.chainId}, Expected: ${desiredChainId}`);
            
            if (network.chainId !== desiredChainId) {
                console.log('⚠️ Wrong network detected, attempting to switch...');
                try {
                    alert('🔄 NETWORK SWITCH REQUIRED\n\nYou need to be on Base Mainnet for this game.\nMetaMask will ask you to switch networks - please confirm.');
                    
                    await provider.provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x2105' }]
                    });
                    console.log('✅ Successfully switched to Base Mainnet');
                } catch (e) {
                    console.warn('❌ Network switch failed:', e);
                    
                    // Chain doesn't exist, try to add it
                    if (e.code === 4902) {
                        console.log('🔧 Base Mainnet not found, adding it...');
                    try {
                        await provider.provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0x2105',
                                    chainName: 'Base Mainnet',
                                nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
                                rpcUrls: ['https://mainnet.base.org'],
                                blockExplorerUrls: ['https://basescan.org']
                            }]
                        });
                            console.log('✅ Base Mainnet added successfully');
                    } catch (e2) {
                            console.error('❌ Failed to add Base Mainnet:', e2);
                            throw new Error('Failed to add Base Mainnet to your wallet. Please add it manually in MetaMask.');
                    }
                    } else if (e.code === 4001) {
                        throw new Error('Network switch rejected by user. Please switch to Base Mainnet manually in MetaMask.');
                    } else {
                        throw new Error(`Cannot switch to Base Mainnet: ${e.message || 'Unknown error'}`);
                }
                }
                
                // Recreate provider/signer/contracts after network switch
                console.log('🔄 Recreating contracts after network switch...');
                if (provider && provider.provider) {
                    provider = new ethers.providers.Web3Provider(provider.provider, 'any');
                    signer = provider.getSigner();
                    userAddress = await signer.getAddress();
                    coffyToken = new ethers.Contract(coffytokenAddress, coffytokenAbi, signer);
                    moduleContract = new ethers.Contract(moduleAddress, moduleAbi, signer);
                    console.log('✅ Contracts recreated successfully');
                }
            } else {
                console.log('✅ Already on correct network (Base Mainnet)');
            }
            
            console.log('🔍 Verifying contract addresses...');
            const codeToken = await provider.getCode(coffytokenAddress);
            const codeModule = await provider.getCode(moduleAddress);
            if (!codeToken || codeToken === '0x') {
                throw new Error(`HUNGX token contract not found at ${coffytokenAddress} on Base Mainnet. Please check contract address.`);
            }
            if (!codeModule || codeModule === '0x') {
                throw new Error(`Game module contract not found at ${moduleAddress} on Base Mainnet. Please check contract address.`);
            }
            console.log('✅ All contracts verified on Base Mainnet');
        }

        async function ensureApproveUnlimited() {
            if (!(await ensureWalletReady())) {
                alert('Please connect your wallet first!');
                return;
            }
            
            console.log('🔍 Checking network and contracts...');
            try {
                await ensureCorrectNetworkAndContracts();
                console.log('✅ Network and contracts verified');
            } catch (e) {
                console.error('❌ Network/contract check failed:', e);
                alert('❌ Network Error:\n\n' + (e.message || 'Wrong network or invalid contract addresses') + '\n\nPlease switch to Base Mainnet.');
                throw e;
            }
            
            console.log('🔍 Checking token allowance...');
            try {
                // Check current allowance
            const allowance = await coffyToken.allowance(userAddress, moduleAddress);
                console.log('Current allowance:', allowance.toString());
                
                if (allowance.lt(MaxUint256.div(2))) { // If not enough allowance
                    console.log('⚠️ Insufficient allowance, requesting approval...');
                    alert('🔐 APPROVAL REQUIRED\n\nYou need to approve HUNGX tokens for this game.\nMetaMask popup will appear - please confirm the transaction.');
                    
                const tx = await coffyToken.approve(moduleAddress, MaxUint256);
                    console.log('📝 Approval transaction sent:', tx.hash);
                    
                await tx.wait();
                    console.log('✅ Approval successful');
                    alert('✅ Token approval successful!');
                } else {
                    console.log('✅ Allowance already sufficient');
                }
            } catch (err) {
                console.error('❌ Allowance/approve failed:', {
                    error: err,
                    message: err.message,
                    reason: err.reason,
                    code: err.code
                });
                
                let errorMsg = '❌ Token Approval Failed!\n\n';
                if (err.code === 4001) {
                    errorMsg += 'You rejected the transaction in MetaMask.';
                } else if (err.reason) {
                    errorMsg += 'Reason: ' + err.reason;
                } else {
                    errorMsg += 'Check you are on Base Mainnet and have enough ETH for gas.';
                }
                
                alert(errorMsg);
                throw err;
            }
        }

        // BattleId / GameId gösterimi ve oyun state eşleştirme
        let currentBattleId = null;
        let currentGameId = null;
        let playerRole = null; // 'initiator' veya 'opponent'

        // Battle katılımcılarını blockchain'den çek
        async function fetchBattlePlayers(battleId) {
            // Minimal ABI'ye ek olarak initiator ve opponent adreslerini almak için ek fonksiyon eklenmeli
            // Şimdilik getBattleResult ile winner ve status alınabiliyor, tam adresler için ek view fonksiyonu gerekebilir
            // Örnek: moduleContract.battles(battleId) ile struct dönebilir (eğer public ise)
            try {
                const battle = await moduleContract.battles(battleId);
                return {
                    initiator: battle.initiator,
                    opponent: battle.opponent
                };
            } catch (e) {
                return { initiator: null, opponent: null };
            }
        }

        // Oyun mantığında, sadece kendi taşını oynayabilen oyuncu kontrolü
        let allowedPlayer = null;
        async function setAllowedPlayer() {
            if (!currentBattleId || !userAddress) return;
            const players = await fetchBattlePlayers(currentBattleId);
            if (players.initiator && players.opponent) {
                if (userAddress.toLowerCase() === players.initiator.toLowerCase()) allowedPlayer = 1;
                else if (userAddress.toLowerCase() === players.opponent.toLowerCase()) allowedPlayer = 2;
                else allowedPlayer = null;
            }
        }

        // --- Oyun süresi ve zamanlayıcı ---
        let matchTimer = null;
        let matchTimeLeft = 300; // 5 dakika (saniye)
        let timerInterval = null;
        // Client timers for multiplayer: UI only (authoritative timing on server)
        function startMatchTimer() {
            // In multiplayer, timer is controlled by server via timerUpdate
            if (multiplayerReady) return;
            matchTimeLeft = 300;
            updateTimerUI(matchTimeLeft);
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                matchTimeLeft--;
                updateTimerUI(matchTimeLeft);
                if (matchTimeLeft <= 0) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                    handleTimeUp();
                }
            }, 1000);
        }
        function ensureTimerPanels() {
            let leftPanel = document.getElementById('timer-panel');
            if (!leftPanel) {
                leftPanel = document.createElement('div');
                leftPanel.id = 'timer-panel';
                leftPanel.style.display = 'flex';
                leftPanel.style.flexDirection = 'column';
                leftPanel.style.alignItems = 'center';
                leftPanel.style.gap = '8px';
                leftPanel.style.width = '90px';
                const leftSide = document.querySelector('.left-panel');
                if (leftSide) {
                    leftSide.prepend(leftPanel);
                } else {
                    const container = document.querySelector('.board-container') || document.querySelector('.game-container');
                    if (container && container.parentElement) {
                        container.parentElement.insertBefore(leftPanel, container);
                    }
                }
            }
            let p1 = document.getElementById('timer-p1');
            let p2 = document.getElementById('timer-p2');
            if (!p1) {
                p1 = document.createElement('div');
                p1.id = 'timer-p1';
                p1.style.cssText = 'font-size:1.4em;font-weight:bold;background:#fffbe6;color:#2c1810;padding:6px 10px;border-radius:8px;text-align:center;';
                leftPanel.appendChild(p1);
            }
            if (!p2) {
                p2 = document.createElement('div');
                p2.id = 'timer-p2';
                p2.style.cssText = 'font-size:1.4em;font-weight:bold;background:#fffbe6;color:#2c1810;padding:6px 10px;border-radius:8px;text-align:center;';
                leftPanel.appendChild(p2);
            }
        }
        function updateTimerUI(totalSeconds) {
            // Single timer legacy UI (single-player)
            let timerBox = document.getElementById('timer-box');
            if (!timerBox) {
                timerBox = document.createElement('div');
                timerBox.id = 'timer-box';
                timerBox.style.fontSize = '2.0em';
                timerBox.style.fontWeight = 'bold';
                timerBox.style.background = '#fffbe6';
                timerBox.style.color = '#2c1810';
                timerBox.style.padding = '6px 12px';
                timerBox.style.borderRadius = '8px';
                timerBox.style.margin = '10px 0';
                timerBox.style.textAlign = 'center';
                document.querySelector('.game-container').prepend(timerBox);
            }
            const min = Math.floor(totalSeconds / 60);
            const sec = totalSeconds % 60;
            timerBox.textContent = `Time Left: ${min}:${sec.toString().padStart(2, '0')}`;
        }
        function updateTimerPanelFromServer(p1Seconds, p2Seconds, currentPlayer) {
            ensureTimerPanels();
            const p1 = document.getElementById('timer-p1');
            const p2 = document.getElementById('timer-p2');
            const fmt = (s) => `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
            p1.textContent = `P1 ${fmt(p1Seconds)}`;
            p2.textContent = `P2 ${fmt(p2Seconds)}`;
            p1.style.outline = currentPlayer === 1 ? '3px solid #4CAF50' : 'none';
            p2.style.outline = currentPlayer === 2 ? '3px solid #4CAF50' : 'none';
        }
        // --- Oyun başlatma akışı ---
        function startBoardAndTimer() {
            console.log('🎮 startBoardAndTimer called - showing board for both players');
            document.getElementById('game-over').style.display = 'none';
            // Board görünürlüğünü ve DOM'da olmasını garanti et
            let board = document.getElementById('board');
            if (!board) {
                board = document.createElement('div');
                board.id = 'board';
                board.className = 'board';
                document.querySelector('.main-board-center')?.appendChild(board);
            } else {
                board.style.display = 'grid'; // Force visible
            }
            
            // Eğer game yoksa yarat, varsa render et
            if (!game) {
            game = new CoffeeCheckersRussian();
                console.log('🎯 New game created');
            } else {
                game.renderBoard(); // Mevcut durum ile render
                console.log('🔄 Existing game re-rendered');
            }
            
            startMatchTimer();
            // Oyun başında ödül butonunu pasif yap
            const claimBtn = document.getElementById('claim-game-reward-btn');
            if (claimBtn) {
                claimBtn.disabled = true;
                claimBtn.style.opacity = '0.5';
            }
        }
        // Oyun sonunda kazanan ödülünü çeksin
        async function claimBattleReward() {
            if (!currentBattleId) return alert('Start or join a battle first!');
            // Only winner can claim
            if (!isWinner()) return alert('Only the winner can claim the reward!');
            const tx = await moduleContract.completeBattleAuto(currentBattleId);
            await tx.wait();
            alert('The winner claimed the reward on-chain!');
        }

        // PvP Game akışı (createGame/joinMultiplayerGame/completeMultiplayerGame)
        async function startPvpGameFlow() {
            if (!(await ensureWalletReady())) {
                alert('Please connect your wallet first!');
                return;
            }
            
            // Use custom stake if provided from modal, otherwise prompt
            let stakeWei;
            let stakeAmountForDisplay;
            if (window.tempStakeAmount) {
                stakeAmountForDisplay = window.tempStakeAmount;
                stakeWei = ethers.utils.parseEther(window.tempStakeAmount.toString());
                window.tempStakeAmount = null; // Clear temp value
            } else {
                const stake = prompt('Stake amount (HUNGX):', '1000');
                if (!stake || isNaN(stake) || parseFloat(stake) < 100) {
                    alert('Minimum 100 HUNGX stake required!');
                    return;
                }
                stakeAmountForDisplay = stake;
                stakeWei = ethers.utils.parseUnits(stake, 18);
            }
            const gameType = 'checkers';
            
            try {
                // Show loading status
                showStatus('🔄 Preparing game creation...', 'waiting', 0);
                
                await ensureApproveUnlimited();
                showStatus('🔄 Creating game on blockchain...', 'waiting', 0);
                
                const tx = await moduleContract.createBattle(stakeWei, { gasLimit: 400000 });
                const receipt = await tx.wait();
                let gameId = null;
                for (const log of receipt.logs) {
                    try {
                        const parsed = moduleContract.interface.parseLog(log);
                        if (parsed.name === 'BattleCreated') {
                            // event BattleCreated(uint256 indexed battleId, address initiator, uint256 stakeAmount)
                            gameId = (parsed.args.battleId || parsed.args[0]).toString();
                            break;
                        }
                    } catch (e) {}
                }
                if (!gameId) {
                    alert('Game creation failed - no GameCreated event found!');
                    return;
                }
                
                console.log(`🎯 Game created with ID: ${gameId}`);
                showStatus(`🎮 Game ${gameId} created! Share this ID with opponent.`, 'success', 0);
                
                // Set current game ID for tracking
                currentGameId = gameId;
                
                // Show game ID prominently in UI
                updateGameIdDisplay(gameId, 'created');
                // Oda akışı
                if (!socket) socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                console.log(`🚀 Creating room with meta: gameId=${currentGameId}, stake=${stakeWei.toString()}`);
                
                const emitCreateRoom = () => socket.emit('createRoom', { gameId: currentGameId, stake: stakeWei.toString() }, (id) => {
                    roomId = id;
                    playerNumber = 1;
                    const queueInfo = document.getElementById('battle-queue-info');
                    const inviteLink = `${location.origin}${location.pathname}?room=${roomId}&gameId=${currentGameId}`;
                    // Fill invite bar and queue info
                    const inviteCodeEl = document.getElementById('invite-code');
                    if (inviteCodeEl) inviteCodeEl.textContent = `Room: ${roomId} | Game ID: ${currentGameId}`;
                    const copyInviteBtn = document.getElementById('copy-invite-link');
                    if (copyInviteBtn && navigator.clipboard) {
                        copyInviteBtn.onclick = async () => {
                            try { await navigator.clipboard.writeText(inviteLink); copyInviteBtn.textContent = 'Copied!'; setTimeout(()=>copyInviteBtn.textContent='Copy Invite Link', 1500); } catch {}
                        };
                    }
                    if (queueInfo) queueInfo.textContent = `Game ID: ${currentGameId} | Room: ${roomId}`;
                    
                    console.log(`✅ Room ${roomId} created with meta immediately available`);
                    // No need for setRoomMeta anymore - meta is set during creation!
                    
                    socket.on('startGame', (gameData) => {
                        console.log('🎮 Enhanced Game starting - both players connected:', gameData);
                        updateGameIdDisplay(currentGameId || gameId, 'active');
                        
                        if (gameData && gameData.freshStart) {
                            console.log('🔄 Fresh multiplayer game starting - resetting board');
                            game = new CoffeeCheckersRussian();
                            game.resetGame();
                        } else if (!game) {
                            game = new CoffeeCheckersRussian();
                            console.log('🎯 Game instance created for multiplayer');
                        }
                        
                        startBoardAndTimer();
                        multiplayerReady = true;
                        setupMultiplayerGameSync(game);
                        if (socket) {
                            // Subscribe to server timer updates
                            if (socket.off) socket.off('timerUpdate');
                            socket.on('timerUpdate', (t) => {
                                updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                            });
                        }
                        if (socket && roomId) {
                            socket.emit('requestSync');
                        }
                        
                        // Update UI to show game is active
                        showStatus(`🎮 Synchronized game started! You are Player ${playerNumber}`, 'success', 4000);
                        
                        // Show prominent game start notification
                        const gameStartModal = document.createElement('div');
                        gameStartModal.style.cssText = `
                            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                            background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                            align-items: center; z-index: 3000; animation: fadeIn 0.5s ease;
                        `;
                        gameStartModal.innerHTML = `
                            <div style="
                                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                                color: #f4e4c1; padding: 30px; border-radius: 20px;
                                border: 3px solid #d4af37; text-align: center;
                                box-shadow: 0 20px 40px rgba(0,0,0,0.5);
                                animation: slideIn 0.5s ease;
                            ">
                                <h2 style="margin: 0 0 15px 0; color: #d4af37; font-size: 2em;">🎮 Game Started!</h2>
                                <p style="margin: 0 0 10px 0; font-size: 1.2em;">Good luck with your match!</p>
                                <p style="margin: 0; font-size: 1em; color: #d4af37;">You are playing as ${playerNumber === 1 ? '☕ Espresso' : '🥛 Latte'}</p>
                            </div>
                        `;
                        document.body.appendChild(gameStartModal);
                        
                        // Auto-close after 3 seconds
                        setTimeout(() => {
                            gameStartModal.style.animation = 'fadeOut 0.5s ease';
                            setTimeout(() => document.body.removeChild(gameStartModal), 500);
                        }, 3000);
                        
                        const currentPlayerEl = document.querySelector('.current-player');
                        if (currentPlayerEl) {
                            currentPlayerEl.style.display = 'block';
                            currentPlayerEl.textContent = playerNumber === 1 ? '☕ Your Turn' : '🥛 Opponent\'s Turn';
                        }
                        
                        console.log(`🔄 Game synchronized - Player ${playerNumber} ready`);
                    });
                });
                if (!socket || !socket.connected) {
                    console.log('⏳ Waiting for socket connection to create room...');
                    socket.once('connect', () => {
                        console.log('🔌 Connected. Emitting createRoom now.');
                        emitCreateRoom();
                    });
                    setTimeout(() => { if (socket && socket.connected && !roomId) emitCreateRoom(); }, 1500);
                } else {
                    emitCreateRoom();
                }
                showStatus(`🎯 Game ${currentGameId} created! Waiting for opponent...`, 'waiting', 0);
                
                alert(`Game created! Game ID: ${currentGameId} | Stake: ${stakeAmountForDisplay} HUNGX`);
            } catch (e) {
                console.error('Game creation failed:', e);
                showStatus('❌ Game creation failed: ' + (e.reason || e.message), 'error', 5000);
                alert('Game creation failed: ' + (e.reason || e.message));
            }
        }
        window.startPvpGameFlow = startPvpGameFlow;

        async function joinPvpGameFlow() {
            if (!(await ensureWalletReady())) {
                alert('Please connect your wallet first!');
                return;
            }
            
            // Use currentGameId if available (from modal), otherwise prompt
            let gameId = currentGameId;
            if (!gameId) {
                gameId = prompt('Enter Game ID to join:');
                if (!gameId || isNaN(gameId)) {
                    alert('Please enter a valid Game ID!');
                    return;
                }
                currentGameId = gameId; // Set for tracking
            }
            
            console.log(`🎯 Joining Game ID: ${gameId}`);
            currentGameId = gameId;
            
            // Connect to Socket.IO first
            if (!socket) {
                socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                console.log('🔌 Socket connected for join flow');
            }
            
            // Find room with this Game ID with retry mechanism
            const findRoomWithRetry = async (retryCount = 0) => {
                return new Promise((resolve) => {
            socket.emit('listRooms', async (openRooms) => {
                        console.log(`🔍 Attempt ${retryCount + 1} - Available rooms:`, openRooms?.map(r => `${r.roomId}(gameId:${r.meta?.gameId || 'none'}, players:${r.playersCount})`));
                        
                        // Filter for the specific gameId AND ensure room is still waiting (1 player)
                const target = (openRooms || []).find(r => 
                            r.meta && 
                            String(r.meta.gameId) === String(gameId) && 
                            r.playersCount === 1
                        );
                        
                        if (!target && retryCount < 3) {
                            console.log(`⏳ Game ID ${gameId} not found or room full, retrying in 1 second... (attempt ${retryCount + 1}/3)`);
                            setTimeout(() => {
                                findRoomWithRetry(retryCount + 1).then(resolve);
                            }, 1000);
                        } else {
                            resolve(target);
                        }
                    });
                });
            };
            
            const target = await findRoomWithRetry();
                
                if (!target) {
                alert(`❌ No waiting room found for Game ID: ${gameId} after 3 attempts.\n\nPossible causes:\n- Game doesn't exist\n- Room already full\n- Creator disconnected`);
                    return;
                }
                
                console.log(`🎲 Found target room: ${target.roomId} for Game ID: ${gameId}`);
                
                // Auto-get stake amount from blockchain game info
                showStatus('🔍 Getting game info from blockchain...', 'waiting', 0);
                let stakeWei;
                try {
                    // Get game info from blockchain
                    const gameInfo = await moduleContract.games(gameId);
                    if (gameInfo && gameInfo.stakeAmount) {
                        stakeWei = gameInfo.stakeAmount;
                        const stakeEther = ethers.utils.formatUnits(stakeWei, 18);
                        const confirmStake = confirm(`Match stake amount: ${stakeEther} HUNGX to join Game ${gameId}?`);
                        if (!confirmStake) return;
                        
                        // Show game info in UI
                        updateGameIdDisplay(gameId, 'joining', stakeEther);
                    } else {
                        throw new Error('Game not found or invalid');
                    }
                } catch (e) {
                    console.warn('Failed to get game info from blockchain:', e);
                    // Fallback to room meta or manual input
                    const stakeFromMeta = target?.meta?.stake;
                    if (stakeFromMeta) {
                        const stakeEther = ethers.utils.formatUnits(stakeFromMeta, 18);
                        const confirmStake = confirm(`Match stake amount: ${stakeEther} HUNGX?`);
                        if (!confirmStake) return;
                        stakeWei = ethers.BigNumber.from(stakeFromMeta);
                    } else {
                        const stake = prompt('Enter stake amount (HUNGX):', '1000');
                        if (!stake || isNaN(stake) || parseFloat(stake) < 100) {
                            alert('Minimum 100 HUNGX stake required!');
                            return;
                        }
                        stakeWei = ethers.utils.parseUnits(stake, 18);
                    }
                }
                
                try {
                    // 1. Show user what's happening
                    showStatus('🔄 Preparing blockchain transaction...', 'waiting', 0);
                    console.log('🔧 Starting approval process...');
                    
                    // 2. Approve & Join blockchain
                    await ensureApproveUnlimited();
                    console.log('✅ Approval successful, preparing join transaction...');
                    
                    showStatus('🔄 Joining game on blockchain... (MetaMask popup should appear)', 'waiting', 0);
                    console.log(`💰 Calling joinMultiplayerGame(${gameId}, ${stakeWei.toString()})`);
                    
                    const tx = await moduleContract.joinMultiplayerGame(gameId, stakeWei, { gasLimit: 400000 });
                    console.log('📝 Transaction sent:', tx.hash);
                    
                    showStatus('⏳ Waiting for blockchain confirmation...', 'waiting', 0);
                    await tx.wait();
                    console.log('✅ Blockchain join successful');
                    
                    // 3. Join Socket.IO room
                    socket.emit('joinRoom', target.roomId, (success) => {
                        if (success) {
                            roomId = target.roomId;
                            playerNumber = 2;
                            console.log(`🚪 Joined room: ${roomId} as Player 2`);
                            
                            // 4. Setup game sync
                            socket.on('startGame', (gameData) => {
                                console.log('🎮 Enhanced startGame received:', gameData);
                                
                                if (gameData && gameData.freshStart) {
                                    console.log('🔄 Fresh multiplayer game starting');
                                    game = new CoffeeCheckersRussian();
                                    game.resetGame();
                                } else if (!game) {
                                    game = new CoffeeCheckersRussian();
                                }
                                
                                startBoardAndTimer();
                                // Subscribe to server timer updates for join flow
                                if (socket && socket.off) socket.off('timerUpdate');
                                socket.on('timerUpdate', (t) => {
                                    updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                                });
                                multiplayerReady = true;
                                setupMultiplayerGameSync(game);
                                saveGameSession();
                                if (socket && roomId) {
                                    socket.emit('requestSync');
                                }
                                showStatus(`🎮 Joined synchronized game! You are Player ${playerNumber}`, 'success', 4000);
                            });
                            
                            showStatus(`✅ Joined Game ${gameId}! Waiting for game to start...`, 'waiting', 0);
                            alert(`✅ Successfully joined Game ${gameId}!\nWaiting for game to start...`);
                        } else {
                            // Room join failed - try to refresh room list and show better error
                            showStatus('❌ Room join failed - refreshing available rooms...', 'error', 3000);
                            alert('❌ Room join failed!\n\nPossible causes:\n- Room is now full (someone else joined first)\n- Room creator disconnected\n- Network issues\n\nTry joining another room or wait for the creator to create a new room.');
                            
                            // Auto-refresh the room list to show current available rooms
                            setTimeout(() => {
                                if (typeof refreshOpenRooms === 'function') {
                                    refreshOpenRooms();
                                }
                            }, 1000);
                        }
                    });
                } catch (e) {
                    console.error('❌ Detailed join error:', {
                        error: e,
                        message: e.message,
                        reason: e.reason,
                        code: e.code,
                        data: e.data
                    });
                    
                    let errorMsg = '❌ Blockchain join failed!\n\n';
                    
                    if (e.code === 4001) {
                        errorMsg += 'Reason: Transaction rejected by user in MetaMask';
                    } else if (e.code === -32603) {
                        errorMsg += 'Reason: Internal JSON-RPC error (check network/contract)';
                    } else if (e.reason) {
                        errorMsg += 'Reason: ' + e.reason;
                    } else if (e.message) {
                        errorMsg += 'Reason: ' + e.message;
                    } else {
                        errorMsg += 'Unknown error occurred';
                    }
                    
                    errorMsg += '\n\nCheck console for technical details.';
                    alert(errorMsg);
                    showStatus('❌ Join failed: ' + (e.reason || e.message || 'Unknown error'), 'error', 8000);
                }
        }
        window.joinPvpGameFlow = joinPvpGameFlow;

        // Enhanced claim system for both battle and casual games
        async function completeGameAndClaim() {
            console.log('🏆 completeGameAndClaim called');
            
            // Winner check
            if (!isWinner()) {
                alert('❌ Only the winner can claim the reward!');
                soundManager.play('error');
                return;
            }
            
            // Wallet check
            if (!(await ensureWalletReady())) {
                alert('❌ Please connect your wallet first!');
                soundManager.play('error');
                return;
            }
            
            // Button feedback
            const btns = [
                document.getElementById('claim-reward-btn'),
                document.getElementById('claim-game-reward-btn')
            ];
            
            btns.forEach(btn => {
                if (btn) {
                    btn.textContent = '⏳ Processing...';
                    btn.disabled = true;
                    btn.style.opacity = '0.7';
                }
            });
            
            // Show processing status
            showStatus('⏳ Processing claim request...', 'info', 2000);
            
            soundManager.play('notification');
            
            try {
                if (currentBattleId) {
                    // Battle mode - blockchain claim
                    await claimBattleReward();
                } else if (currentGameId) {
                    // Casual multiplayer game
                    await claimMultiplayerReward();
                } else {
                    // Solo game
                    await claimSoloReward();
                }
                
            } catch (error) {
                console.error('Claim failed:', error);
                alert('❌ Claim failed: ' + (error.reason || error.message || error));
                soundManager.play('error');
                
                // Reset buttons
                btns.forEach(btn => {
                    if (btn) {
                        btn.textContent = '🏆 Claim Reward';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }
                });
            }
        }
        
        async function claimBattleReward() {
            console.log(`🏆 Claiming battle reward for battle ${currentBattleId}`);
            showStatus('🔄 Claiming battle reward on blockchain...', 'waiting');
            try {
                const tx = await moduleContract.completeBattleAuto(currentBattleId, { gasLimit: 400000 });
                await tx.wait();
                
                // Success feedback
                soundManager.playSequence(['win', 'steam', 'notification'], 300);
                showStatus('🎉 Battle reward claimed successfully!', 'success', 5000);
                alert('🏆 Battle reward claimed successfully from blockchain!');
                
                updateClaimButtonsSuccess('Battle Reward Claimed ✅');
                
                // Update battle display
                const battleIdBox = document.getElementById('battle-id-box');
                if (battleIdBox) {
                    battleIdBox.textContent = `Battle ${currentBattleId} - Reward Claimed ✅`;
                    battleIdBox.style.background = '#4CAF50';
                }
            } catch (e) {
                const reason = e?.reason || e?.error?.message || e?.message || '';
                const reasonStr = String(reason).toLowerCase();
                    if (reasonStr.includes('battle too short')) {
                    	showStatus('⏳ Battle must last at least 3 minutes. Please wait a bit longer.', 'info', 5000);
                    } else if (reasonStr.includes('battle not active')) {
                    // Likely already completed; show non-blocking success
                    showStatus('ℹ️ Battle already completed. If you are the winner, reward should be received.', 'info', 6000);
                    } else if (reasonStr.includes('only participants')) {
                    	showStatus('❌ Only participants can complete.', 'error', 5000);
                } else {
                    throw e;
                }
            }
        }
        
        // CORRECT ORDER: completeGame FIRST, then claimGameWin
        async function claimMultiplayerReward() {
            console.log(`🏆 Claiming multiplayer reward for game ${currentGameId}`);
            
            try {
                // STEP 1: Complete the game first
                if (!onchainGame.completed) {
                    console.log('🏆 Step 1: Completing game', currentGameId);
                    showStatus('⏳ Step 1/2: Completing game...', 'info', 2000);
                    try {
                        const completeTx = await moduleContract.completeGame(currentGameId, userAddress, { gasLimit: 350000 });
                        console.log('🏆 Complete game transaction sent:', completeTx.hash);
                        await completeTx.wait();
                        console.log('✅ Game completed successfully');
                        onchainGame.completed = true;
                    } catch (e) {
                        const reason = e?.reason || e?.error?.message || e?.message || '';
                        // If already completed, proceed to claim
                        if (typeof reason === 'string' && reason.toLowerCase().includes('game already completed')) {
                            console.warn('ℹ️ Game already completed on-chain, proceeding to claim...');
                            onchainGame.completed = true;
                        } else {
                            console.error('❌ Failed to complete game:', reason);
                            throw e;
                        }
                    }
                } else {
                    console.log('ℹ️ Game already completed on-chain, skipping completeGame');
                }
                
                // Small delay to ensure blockchain state update
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // STEP 2: Now claim the win
                console.log('🏆 Step 2: Claiming game win', currentGameId);
                showStatus('⏳ Step 2/2: Claiming reward...', 'info', 2000);
                
                const claimTx = await moduleContract.claimGameWin(currentGameId, { gasLimit: 350000 });
                console.log('🏆 Claim game win transaction sent:', claimTx.hash);
                await claimTx.wait();
                console.log('✅ Game win claimed successfully');
                onchainGame.claimed = true;
                
                showStatus('🎉 Multiplayer reward claimed successfully!', 'success', 8000);
                alert('🏆 Multiplayer game completed and reward claimed successfully!');
                
                updateClaimButtonsSuccess('Multiplayer Reward Claimed ✅');
                
            } catch (error) {
                console.error('❌ Claim multiplayer reward failed:', error);
                throw error;
            }
        }
        
        async function claimSoloReward() {
            console.log('🏆 Claiming solo game reward');
            showStatus('🎉 Congratulations on your solo victory!', 'success', 3000);
            
            // Solo mode - just confirmation and UI feedback
            soundManager.playSequence(['win', 'steam', 'notification'], 200);
            alert('🎉 Congratulations! You completed the solo game!');
            
            updateClaimButtonsSuccess('Solo Victory Confirmed ✅');
            
            // Auto-hide winner panel after 5 seconds
            setTimeout(() => {
                const winnerPanel = document.getElementById('winner-panel');
                if (winnerPanel) {
                    winnerPanel.style.display = 'none';
                }
            }, 5000);
        }
        
        function updateClaimButtonsSuccess(message) {
            const btns = [
                document.getElementById('claim-reward-btn'),
                document.getElementById('claim-game-reward-btn')
            ];
            
            btns.forEach(btn => {
                if (btn) {
                    btn.textContent = message;
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                    btn.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                }
            });
            
            // Update winner message
            const winnerMessage = document.getElementById('winner-message');
            if (winnerMessage) {
                winnerMessage.textContent = '🎉 Reward Claimed Successfully!';
            }
        }
        window.completeGameAndClaim = completeGameAndClaim;
        // Kazanan oyuncu kontrolü - multiplayer için playerNumber kullan
        function isWinner() {
            // Solo modda hep kazanan sayılır
            if (!multiplayerReady) {
                console.log('🏆 Solo mode - player is always winner');
                return true;
            }
            
            // Global gameWinner varsa onu kullan
            if (window.gameWinner) {
                const isWin = (playerNumber === window.gameWinner);
                console.log(`🏆 isWinner check: playerNumber=${playerNumber}, gameWinner=${window.gameWinner}, result=${isWin}`);
                return isWin;
            }
            
            // Game objesinden score kontrolü
            if (window.game) {
                let winnerPlayer = null;
                if (game.player1Score === 0) winnerPlayer = 2;
                else if (game.player2Score === 0) winnerPlayer = 1;
                else if (game.gameOver) {
                    // Hamle yapamayan oyuncu kaybeder
                    winnerPlayer = game.currentPlayer === 1 ? 2 : 1;
                }
                
                if (winnerPlayer) {
                    const isWin = (playerNumber === winnerPlayer);
                    console.log(`🏆 Score-based winner check: winnerPlayer=${winnerPlayer}, playerNumber=${playerNumber}, result=${isWin}`);
                    return isWin;
                }
            }
            
            // Fallback: text-based check
            const winnerText = document.getElementById('winner-text')?.textContent || '';
            if (winnerText.includes('☕ Espresso') && playerNumber === 1) return true;
            if (winnerText.includes('🥛 Latte') && playerNumber === 2) return true;
            
            console.log('🏆 No winner determined yet');
            return false;
        }
        // Oyun bittiğinde ödül butonunu sadece kazanan için aktif et
        function enableClaimButtonIfWinner() {
            console.log('🏆 enableClaimButtonIfWinner called');
            
            // Her iki claim butonunu da kontrol et
            const gameClaimBtn = document.getElementById('claim-game-reward-btn');
            const winnerClaimBtn = document.getElementById('claim-reward-btn');
            const winnerPanel = document.getElementById('winner-panel');
            const winnerMessage = document.getElementById('winner-message');
            
            const canClaim = isWinner();
            
            // Game reward claim button
            if (gameClaimBtn) {
                if (canClaim) {
                    gameClaimBtn.disabled = false;
                    gameClaimBtn.style.opacity = '1';
                    gameClaimBtn.textContent = currentBattleId ? '🏆 Claim Battle Reward' : '🎉 Claim Victory';
                } else {
                    gameClaimBtn.disabled = true;
                    gameClaimBtn.style.opacity = '0.5';
                    gameClaimBtn.textContent = '❌ Not Winner';
                }
            }
            
            // Winner panel claim button
            if (winnerPanel && winnerMessage && winnerClaimBtn) {
                winnerPanel.style.display = 'block';
                
                if (canClaim) {
                    winnerMessage.textContent = '🎉 Congratulations! You Won!';
                    winnerClaimBtn.style.display = 'block';
                    winnerClaimBtn.disabled = false;
                    winnerClaimBtn.style.opacity = '1';
                    winnerClaimBtn.textContent = currentBattleId ? '🏆 Claim Battle Reward' : '🎉 Claim Victory';
                    
                    // Başarı mesajı göster
                    showStatus('🎉 You won! Click to claim your reward!', 'success', 5000);
                    soundManager.play('win');
                } else {
                    winnerMessage.textContent = multiplayerReady ? 'Your opponent won this battle.' : 'Game completed!';
                    winnerClaimBtn.style.display = 'none';
                    showStatus('😔 Better luck next time!', 'info', 3000);
                }
            }
            
            console.log(`🏆 Claim buttons updated - canClaim: ${canClaim}, battleId: ${currentBattleId || 'none'}`);
        }
        // Oyun bittiğinde veya süre bittiğinde çağrılır
        function handleTimeUp() {
            // Taş sayısına göre kazananı belirle
            let winner = null;
            if (game.player1Score > game.player2Score) winner = '☕ Espresso';
            else if (game.player2Score > game.player1Score) winner = '🥛 Latte';
            else winner = 'Berabere';
                const gameOverElement = document.getElementById('game-over');
                const winnerText = document.getElementById('winner-text');
            winnerText.textContent = matchTimeLeft === 0 ? `Time's up! Winner: ${winner}` : `${winner} Won!`;
            gameOverElement.style.display = 'block';
            enableClaimButtonIfWinner();
        }
        // Oyun bittiğinde (normal bitişte de) ödül butonunu kontrol et
        CoffeeCheckersRussian.prototype.showGameOver = function() {
            const gameOverElement = document.getElementById('game-over');
            const winnerText = document.getElementById('winner-text');
                let winner;
                if (this.player1Score === 0) {
                    winner = '🥛 Latte';
                } else if (this.player2Score === 0) {
                    winner = '☕ Espresso';
                } else {
                    winner = this.currentPlayer === 1 ? '🥛 Latte' : '☕ Espresso';
                }
                                winnerText.textContent = `${winner} Won!`;
                gameOverElement.style.display = 'block';
                
                // Global winner'ı kaydet
                let winnerPlayerNumber;
                if (this.player1Score === 0) {
                    winnerPlayerNumber = 2;
                } else if (this.player2Score === 0) {
                    winnerPlayerNumber = 1;
                } else {
                    winnerPlayerNumber = this.currentPlayer === 1 ? 2 : 1;
                }
                window.gameWinner = winnerPlayerNumber;
                console.log(`🏆 Final Override - Winner set to Player ${winnerPlayerNumber}`);
                
                // Show victory/defeat notification for multiplayer
                if (multiplayerReady) {
                    console.log(`🎮 Game Over - Winner: ${winner}, PlayerNumber: ${playerNumber}, MultiplayerReady: ${multiplayerReady}`);
                    
                    if (playerNumber === winnerPlayerNumber) {
                        console.log('🎉 This player WON! Showing claim button');
                        showStatus(`🎉 Victory! You won as ${winner}!`, 'success', 10000);
                        soundManager.playSequence(['win', 'steam'], 500);
                        showWinnerPanel(true);
                    } else {
                        console.log('😔 This player LOST! No claim button');
                        showStatus(`😔 Defeat! ${winner} won this round.`, 'warning', 8000);
                        soundManager.play('error');
                        showWinnerPanel(false);
                    }
                } else {
                    // Single player mode - always show claim
                    showWinnerPanel(true);
                }
                
                // Claim sistemi kurulumu
                setTimeout(() => {
                    enableClaimButtonIfWinner();
                }, 1500);
        };
        // --- Oyun başlatma akışı ---
        function startBoardAndTimer() {
            document.getElementById('game-over').style.display = 'none';
            
            // Board'ın var olduğundan emin ol
            let board = document.getElementById('board');
            if (board) {
                board.style.display = 'grid'; // Board'ı görünür yap
            }
            
            // Oyunu başlat
            if (!game) {
                game = new CoffeeCheckersRussian();
            } else {
                // Mevcut oyunu sıfırla
                game.initializeBoard();
                game.renderBoard();
                game.updateUI();
            }
            
            startMatchTimer();
            
            // Oyun başında ödül butonunu pasif yap
            const claimBtn = document.getElementById('claim-game-reward-btn');
            if (claimBtn) {
                claimBtn.disabled = true;
                claimBtn.style.opacity = '0.5';
            }
            
            console.log('Board and timer started, game initialized');
        }
        // Battle başlat (ilk oyuncu)
        async function startBattleFlow() {
            if (!(await ensureWalletReady())) {
                alert('Please connect your wallet first!');
                return;
            }
            
            const stake = prompt('Stake miktarını girin (HUNGX):', '1000');
            if (!stake || isNaN(stake) || parseFloat(stake) < 100) {
                alert('Minimum 100 HUNGX stake gerekli!');
                return;
            }
            
            // Önce oyunu başlat ve tahtayı görünür yap
            if (!game) {
                newGame(false); // Oyunu başlat
            }
            
            // Board'ın görünür olduğundan emin ol
            const board = document.getElementById('board');
            if (board) {
                board.style.display = 'grid';
            }
            
            const stakeWei = ethers.utils.parseUnits(stake, 18);
            const gameType = 'checkers';
            
            await ensureApproveUnlimited();
            
            try {
                // Contract createBattle only accepts (uint256 _stakeAmount)
                const tx = await moduleContract.createBattle(stakeWei, gameType, { gasLimit: 500000 });
                const receipt = await tx.wait();
                
                // BattleId'yi eventten bul
                let battleId = null;
                for (const log of receipt.logs) {
                    try {
                        const parsed = moduleContract.interface.parseLog(log);
                        if (parsed.name === 'BattleCreated') {
                            // event BattleCreated(uint256 indexed battleId, address indexed initiator, uint256 stakeAmount)
                            battleId = (parsed.args.battleId || parsed.args[0]).toString();
                            break;
                        }
                    } catch (e) {}
                }
                
                if (battleId) {
                    currentBattleId = battleId;
                    playerRole = 'initiator';
                    playerNumber = 1; // Battle başlatan oyuncu 1
                    await setAllowedPlayer();
                    
                    // Socket bağlantısı kur
                    if (!socket) {
            socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                        setupMultiplayerGameSync(game);
                    }
                    
                    // Yeni battle info panelini göster
                    showBattleInfo(battleId, stake, 'pending');
                    
                    alert(`Battle created!\nBattle ID: ${battleId}\nStake: ${stake} HUNGX\n\nShare this ID for the opponent to join.\n\nBoard is ready, waiting for opponent...`);
                    
                    // Multiplayer oda oluştur ve oda kodunu göster
                    const emitCreateRoom = () => socket.emit('createRoom', (id) => {
                        roomId = id;
                        const queueInfo = document.getElementById('battle-queue-info');
                        if (queueInfo) {
                            queueInfo.textContent = `Room Code: ${roomId} (share with opponent)`;
                        }
                        console.log(`Room created for battle ${battleId}: ${roomId}`);

                        // İkinci oyuncu katıldığında server 'startGame' yayınlar
                        socket.on('startGame', (gameData) => {
                            console.log('🎮 Battle startGame received:', gameData);
                            // Odayı battle ile eşleştir
                            socket.emit('linkBattleToRoom', battleId, roomId);
                            // Tahtayı başlat
                            startBoardAndTimer();
                            // Subscribe to server timer updates
                            if (socket && socket.off) socket.off('timerUpdate');
                            socket.on('timerUpdate', (t) => {
                                updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                            });
                            multiplayerReady = true;
                            setupMultiplayerGameSync(game);
                            if (socket && roomId) {
                                socket.emit('requestSync');
                            }
                            showStatus(`🎮 Battle game started! You are Player ${playerNumber}`, 'success', 4000);
                        });
                    });
                    if (!socket || !socket.connected) {
                        console.log('⏳ Waiting for socket connection to create battle room...');
                        socket.once('connect', () => emitCreateRoom());
                        setTimeout(() => { if (socket && socket.connected && !roomId) emitCreateRoom(); }, 1500);
                    } else {
                        emitCreateRoom();
                    }
                    
                    // Battle durumunu zincirden takip et
                    checkBattleStatus(battleId);
                } else {
                    alert('Battle oluşturuldu ama ID alınamadı. Transaction: ' + tx.hash);
                }
            } catch (e) {
                alert('Battle oluşturma başarısız: ' + (e.reason || e.message));
                console.error(e);
            }
        }
        
        // Battle'a katıl (ikinci oyuncu)
        async function joinBattleFlow() {
            if (!(await ensureWalletReady())) {
                alert('Please connect your wallet first!');
                return;
            }
            
            const battleId = prompt('Enter the Battle ID to join:');
            if (!battleId || isNaN(battleId)) {
                alert('Please enter a valid Battle ID!');
                return;
            }
            
            await ensureApproveUnlimited();
            
            try {
                const tx = await moduleContract.joinBattle(battleId, { gasLimit: 300000 });
                await tx.wait();
                
                currentBattleId = battleId;
                playerRole = 'opponent';
                playerNumber = 2; // Katılan oyuncu player 2
                await setAllowedPlayer();
                
                // Battle info panelini güncelle
                const stakeAmount = await getBattleStakeAmount(battleId);
                showBattleInfo(battleId, stakeAmount, 'active');
                
                // Socket bağlantısı kur ve odaya katıl
                if (!socket) socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                const code = prompt('Room Code (6 characters shared by the creator):');
                if (!code || code.length !== 6) {
                    alert('Please enter a valid 6-character room code.');
                    return;
                }
                socket.emit('joinRoom', code.toUpperCase(), (success) => {
                    if (success) {
                        roomId = code.toUpperCase();
                        // Katılım tamam, server 'startGame' yayınlayacak
                        socket.on('startGame', (gameData) => {
                            console.log('🎮 Battle join startGame received:', gameData);
                                startBoardAndTimer();
                                // Subscribe to server timer updates
                                if (socket && socket.off) socket.off('timerUpdate');
                                socket.on('timerUpdate', (t) => {
                                    updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                                });
                            multiplayerReady = true;
                            setupMultiplayerGameSync(game);
                            if (socket && roomId) {
                                socket.emit('requestSync');
                            }
                            showStatus(`🎮 Battle joined! You are Player ${playerNumber}`, 'success', 4000);
                        });
                        alert('Battle\'a ve odaya katıldınız! Oyun başlıyor...');
                    } else {
                        alert('Odaya katılım başarısız. Oda bulunamadı veya dolu.');
                    }
                });
                
            } catch (e) {
                alert('Battle\'a katılma başarısız: ' + (e.reason || e.message));
                console.error(e);
            }
        }
        
        // Battle durumunu kontrol et
        async function checkBattleStatus(battleId) {
            try {
                const battle = await moduleContract.battles(battleId);
                const statusNum = (battle.status && typeof battle.status.toNumber === 'function') ? battle.status.toNumber() : Number(battle.status);
                if (statusNum === 1) { // Active
                    const stakeAmount = ethers.utils.formatUnits(battle.stakeAmount, 18);
                    showBattleInfo(battleId, stakeAmount, 'active');
                    
                    // Multiplayer aktif et
                    multiplayerReady = true;
                    
                    // Board'ın görünür olduğundan emin ol
                    const board = document.getElementById('board');
                    if (board) {
                        board.style.display = 'grid';
                    }
                    
                    // Timer başlat
                    startMatchTimer();
                    
                    alert('Opponent joined! Blockchain multiplayer starting...');
                    
                } else if (statusNum === 0) { // Pending
                    // 5 saniye sonra tekrar kontrol et
                    setTimeout(() => checkBattleStatus(battleId), 5000);
                }
            } catch (e) {
                console.error('Battle status check failed:', e);
            }
        }

        // Battle stake miktarını al
        async function getBattleStakeAmount(battleId) {
            try {
                const battle = await moduleContract.battles(battleId);
                return ethers.utils.formatUnits(battle.stakeAmount, 18);
            } catch (e) {
                console.error('Failed to get battle stake:', e);
                return '0';
            }
        }

        // Battle bilgi paneli göster
        function showBattleInfo(battleId, stake, status = 'pending') {
            const container = document.getElementById('battle-info-container');
            if (!container) return;
            
            const statusText = {
                'pending': 'Waiting for opponent...',
                'active': 'Active',
                'completed': 'Completed'
            };
            
            const statusColor = {
                'pending': '#f39c12',
                'active': '#27ae60',
                'completed': '#3498db'
            };
            
            container.innerHTML = `
                <div class="battle-info" style="background: linear-gradient(135deg, ${statusColor[status]}, #f4e4c1);">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>⚔️ Battle ID: ${battleId}</strong>
                            <div class="stake-info">💰 Stake: ${stake} HUNGX</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 2.4em;">📊 ${statusText[status]}</div>
                            <div id="timer-box" class="timer-display" style="display: none;"></div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Enhanced Battle UI with Multi-Wallet Support
        function addBattleUI() {
            const gameContainer = document.querySelector('.game-container');
            const controls = document.querySelector('.controls');
            
            // Check if already mounted to prevent duplicates
            if (document.getElementById('pvp-ui') || document.querySelector('.wallet-info')) return;
            
            // Compact UI Container
            const compactUI = document.createElement('div');
            compactUI.id = 'pvp-ui';
            compactUI.style.cssText = `
                background: rgba(139, 69, 19, 0.1);
                border: 1px solid rgba(212, 175, 55, 0.3);
                border-radius: 8px;
                padding: 8px;
                margin: 8px 0;
                font-size: 0.9em;
            `;
            
            compactUI.innerHTML = `
                <!-- Wallet Section -->
                <div class="wallet-info" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.7em;">Wallet:</span>
                        <span id="wallet-address" style="display: none; color: #d4af37; font-weight: bold; font-size: 1.6em;"></span>
                        <button class="btn" id="connect-btn" onclick="connectWallet()" style="padding: 3px 7px; font-size: 1.36em;">🔗 Connect</button>
                    </div>
                    <div id="wallet-status" style="font-size: 1.5em; color: #f4e4c1;"></div>
                </div>
                
                <!-- Game Controls -->
                <div style="display: flex; gap: 8px; justify-content: center; margin-bottom: 8px;">
                    <button class="btn battle-btn" id="create-game-btn" style="padding: 5px 10px; font-size: 1.45em;">🎯 Create</button>
                    <button class="btn battle-btn" id="join-game-btn" style="padding: 5px 10px; font-size: 1.45em;">🎮 Join</button>
                    <button class="btn" id="refresh-rooms-btn" style="padding: 5px 8px; font-size: 1.36em;">📋 Rooms</button>
                </div>
                
                <!-- Game Info -->
                <div id="battle-queue-info" style="text-align: center; font-size: 1.6em; color: #d4af37; margin-bottom: 8px;"></div>
                
                <!-- Open Rooms (Collapsible) -->
                <div id="open-rooms-panel" style="display: none;">
                    <div style="border-top: 1px solid rgba(212, 175, 55, 0.2); padding-top: 8px;">
                        <div style="font-size: 1.6em; color: #d4af37; margin-bottom: 6px;">🎲 Available Games:</div>
                        <div id="open-rooms-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 6px; max-height: 100px; overflow-y: auto;"></div>
                    </div>
                </div>
            `;
            // Insert before controls or at the end of game container
            if (controls) {
                controls.parentNode.insertBefore(compactUI, controls);
            } else {
                gameContainer.appendChild(compactUI);
            }
            
            // Event listeners
            document.getElementById('create-game-btn').onclick = () => startPvpGameFlow();
            document.getElementById('join-game-btn').onclick = () => joinPvpGameFlow();
            document.getElementById('refresh-rooms-btn').onclick = () => {
                const panel = document.getElementById('open-rooms-panel');
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    refreshOpenRooms();
                } else {
                    panel.style.display = 'none';
                }
            };
            // Auto refresh open rooms
            refreshOpenRooms();
            if (!window.__roomsInterval) {
                window.__roomsInterval = setInterval(refreshOpenRooms, 10000);
            }
            
            // Battle Info Container
            const battleInfoContainer = document.createElement('div');
            battleInfoContainer.id = 'battle-info-container';
            battleInfoContainer.style.marginTop = '15px';
            gameContainer.insertBefore(battleInfoContainer, gameContainer.children[2]);
            
            // Invite bar just above the board
            const inviteBar = document.createElement('div');
            inviteBar.id = 'invite-bar';
            inviteBar.style.cssText = 'margin:10px 0; text-align:center;';
            inviteBar.innerHTML = `
                <div style="display:flex; gap:8px; justify-content:center; align-items:center; flex-wrap:wrap;">
                    <span id="invite-code" style="font-weight:bold;"></span>
                    <button class="btn" id="copy-invite-link" style="padding:6px 10px; font-size:0.9em;">Copy Invite Link</button>
                </div>
            `;
            gameContainer.insertBefore(inviteBar, document.getElementById('board'));
            
            // Enhanced Game Over Panel with Rewards
            const gameOverDiv = document.getElementById('game-over');
            const rewardSection = document.createElement('div');
            rewardSection.innerHTML = `
                <div style="margin-top: 15px; padding: 15px; background: rgba(139, 69, 19, 0.2); border-radius: 10px;">
                    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                        <button class="btn battle-btn" id="claim-game-reward-btn" onclick="completeGameAndClaim()" disabled style="opacity: 0.5;">
                            🏆 Confirm Winner & Claim
                    </button>
                    </div>
                    <div id="reward-info" style="margin-top: 10px; font-size: 0.9em; text-align: center;"></div>
                </div>
            `;
            gameOverDiv.appendChild(rewardSection);
            
            // Connected Wallets Display
            const connectedWalletsDiv = document.createElement('div');
            connectedWalletsDiv.id = 'connected-wallets';
            connectedWalletsDiv.style.cssText = `
                margin-top: 10px; padding: 10px; background: rgba(139, 69, 19, 0.1);
                border-radius: 8px; font-size: 0.8em; display: none;
            `;
            // Remove this line as walletInfo is not defined in current context
        }

        // Show Battle Creation Modal
        function showBattleCreationModal() {
            if (!userAddress) {
                alert('Please connect your wallet first!');
                return;
            }

            const modalDiv = document.createElement('div');
            modalDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 3000;`;
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                color: #f4e4c1; padding: 30px; border-radius: 15px;
                border: 2px solid #d4af37; max-width: 500px; width: 90%;
                box-shadow: 0 15px 35px rgba(0,0,0,0.5);`;
            
            contentDiv.innerHTML = `
                <h2 style="text-align: center; margin-bottom: 20px;">⚔️ Create Battle</h2>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Stake Miktarı (HUNGX):</label>
                    <input type="number" id="stake-amount" placeholder="1000" min="100"
                           style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #d4af37; background: #2c1810; color: #f4e4c1;">
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Oyun Türü:</label>
                    <select id="game-type" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #d4af37; background: #2c1810; color: #f4e4c1;">
                        <option value="checkers">Coffee Checkers</option>
                        <option value="quick">Hızlı Battle</option>
                        <option value="tournament">Turnuva</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Battle Süresi:</label>
                    <select id="battle-duration" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #d4af37; background: #2c1810; color: #f4e4c1;">
                        <option value="300">5 Minutes</option>
                        <option value="600">10 Minutes</option>
                        <option value="900">15 Minutes</option>
                        <option value="1800">30 Minutes</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 20px; padding: 10px; background: rgba(212, 175, 55, 0.1); border-radius: 5px;">
                    <div style="font-size: 0.9em;">
                        <div>💼 Wallet: ${getWalletIcon(currentWalletType)} ${userAddress.slice(0, 8)}...${userAddress.slice(-6)}</div>
                        <div>🌐 Tarayıcı: ${getBrowserInfo()}</div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn battle-btn" onclick="createBattleFromModal()">⚔️ Create Battle</button>
                    <button class="btn" onclick="closeBattleModal()" style="background: #666;">Cancel</button>
                </div>
                
                <div id="creation-status" style="margin-top: 15px; text-align: center; font-size: 0.9em;"></div>
            `;
            
            modalDiv.appendChild(contentDiv);
            document.body.appendChild(modalDiv);
            
            window.closeBattleModal = () => modalDiv.remove();
            window.createBattleFromModal = () => createBattleFromModal(modalDiv);
        }

        // Show Battle Join Modal
        function showBattleJoinModal() {
            if (!userAddress) {
                alert('Please connect your wallet first!');
                return;
            }

            const modalDiv = document.createElement('div');
            modalDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); display: flex; justify-content: center;
                align-items: center; z-index: 3000;`;
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
                background: linear-gradient(135deg, #4a2c20, #6b3e29);
                color: #f4e4c1; padding: 30px; border-radius: 15px;
                border: 2px solid #d4af37; max-width: 600px; width: 90%;
                box-shadow: 0 15px 35px rgba(0,0,0,0.5);`;
            
            contentDiv.innerHTML = `
                <h2 style="text-align: center; margin-bottom: 20px;">🎯 Join Battle</h2>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 5px;">Battle ID:</label>
                    <input type="text" id="join-battle-id" placeholder="Battle ID girin"
                           style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #d4af37; background: #2c1810; color: #f4e4c1;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <button class="btn" onclick="loadActiveBattles()" style="width: 100%;">🔄 Aktif Battle'ları Yükle</button>
                </div>
                
                <div id="active-battles-list" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;"></div>
                
                <div style="margin-bottom: 20px; padding: 10px; background: rgba(212, 175, 55, 0.1); border-radius: 5px;">
                    <div style="font-size: 0.9em;">
                        <div>💼 Wallet: ${getWalletIcon(currentWalletType)} ${userAddress.slice(0, 8)}...${userAddress.slice(-6)}</div>
                        <div>🌐 Tarayıcı: ${getBrowserInfo()}</div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn battle-btn" onclick="joinBattleFromModal()">🎯 Katıl</button>
                    <button class="btn" onclick="closeBattleJoinModal()" style="background: #666;">Cancel</button>
                </div>
                
                <div id="join-status" style="margin-top: 15px; text-align: center; font-size: 0.9em;"></div>
            `;
            
            modalDiv.appendChild(contentDiv);
            document.body.appendChild(modalDiv);
            
            // Load active battles automatically
            loadActiveBattles();
            
            window.closeBattleJoinModal = () => modalDiv.remove();
            window.joinBattleFromModal = () => joinBattleFromModal(modalDiv);
        }

        // Get browser info
        function getBrowserInfo() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome')) return '🌐 Chrome';
            if (ua.includes('Firefox')) return '🦊 Firefox';
            if (ua.includes('Safari')) return '🧭 Safari';
            if (ua.includes('Edge')) return '🔷 Edge';
            return '🌐 Browser';
        }

        // Create battle from modal
        async function createBattleFromModal(modal) {
            const stakeAmount = document.getElementById('stake-amount').value;
            const gameType = document.getElementById('game-type').value;
            const duration = document.getElementById('battle-duration').value;
            const statusDiv = document.getElementById('creation-status');
            
            if (!stakeAmount || parseFloat(stakeAmount) < 100) {
                statusDiv.innerHTML = '<span style="color: #e74c3c;">❌ Minimum 100 HUNGX stake gerekli!</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span style="color: #f39c12;">⏳ Battle oluşturuluyor...</span>';
            
            try {
                await createBattleWithParams(stakeAmount, gameType, duration);
                statusDiv.innerHTML = '<span style="color: #27ae60;">✅ Battle başarıyla oluşturuldu!</span>';
                setTimeout(() => modal.remove(), 2000);
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: #e74c3c;">❌ Hata: ${error.message}</span>`;
            }
        }

        // Join battle from modal
        async function joinBattleFromModal(modal) {
            const battleId = document.getElementById('join-battle-id').value;
            const statusDiv = document.getElementById('join-status');
            
            if (!battleId) {
                statusDiv.innerHTML = '<span style="color: #e74c3c;">❌ Battle ID gerekli!</span>';
                return;
            }
            
            statusDiv.innerHTML = '<span style="color: #f39c12;">⏳ Battle\'a katılınıyor...</span>';
            
            try {
                await joinBattleWithId(battleId);
                statusDiv.innerHTML = '<span style="color: #27ae60;">✅ Battle\'a başarıyla katıldınız!</span>';
                setTimeout(() => modal.remove(), 2000);
            } catch (error) {
                statusDiv.innerHTML = `<span style="color: #e74c3c;">❌ Hata: ${error.message}</span>`;
            }
        }

        // Create battle with parameters
        async function createBattleWithParams(stakeAmount, gameType, duration) {
            if (!coffyToken || !userAddress) {
                throw new Error('Wallet not connected!');
            }
            
            // Önce oyunu başlat ve tahtayı görünür yap
            if (!game) {
                newGame(false);
            }
            
            const board = document.getElementById('board');
            if (board) {
                board.style.display = 'grid';
            }
            
            const stakeWei = ethers.utils.parseUnits(stakeAmount, 18);
            await ensureApproveUnlimited();
            
            const tx = await moduleContract.createBattle(stakeWei, gameType, { gasLimit: 500000 });
            const receipt = await tx.wait();
            
            // BattleId'yi eventten bul
            let battleId = null;
            for (const log of receipt.logs) {
                try {
                    const parsed = moduleContract.interface.parseLog(log);
                    if (parsed.name === 'BattleCreated') {
                        battleId = (parsed.args.battleId || parsed.args[0]).toString();
                        break;
                    }
                } catch (e) {}
            }
            
            if (battleId) {
                currentBattleId = battleId;
                playerRole = 'initiator';
                playerNumber = 1;
                await setAllowedPlayer();
                
                // Socket bağlantısı kur
                if (!socket) {
                    socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                    setupMultiplayerGameSync(game);
                }
                
                showBattleInfo(battleId, stakeAmount, 'pending');
                
                // Multiplayer oda oluştur ve battle ile bağla
                const emitCreateRoom = () => socket.emit('createRoom', (id) => {
                    roomId = id;
                    socket.emit('linkBattleToRoom', battleId, roomId);
                    console.log(`Battle ${battleId} linked to room ${roomId}`);
                });
                if (!socket || !socket.connected) {
                    console.log('⏳ Waiting for socket connection to create battle-linked room...');
                    socket.once('connect', () => emitCreateRoom());
                    setTimeout(() => { if (socket && socket.connected && !roomId) emitCreateRoom(); }, 1500);
                } else {
                    emitCreateRoom();
                }
                
                checkBattleStatus(battleId);
                
                // Update wallet status
                updateWalletStatus(`Battle ${battleId} created - Waiting for opponent...`);
            }
        }

        // Join battle with ID
        async function joinBattleWithId(battleId) {
            if (!coffyToken || !userAddress) {
                throw new Error('Wallet not connected!');
            }
            
            await ensureApproveUnlimited();
            
            const tx = await moduleContract.joinBattle(battleId, { gasLimit: 300000 });
            await tx.wait();
            
            currentBattleId = battleId;
            playerRole = 'opponent';
            playerNumber = 2;
            await setAllowedPlayer();
            
            const stakeAmount = await getBattleStakeAmount(battleId);
            showBattleInfo(battleId, stakeAmount, 'active');
            
            if (!socket) {
                socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
            }
            
            startBoardAndTimer();
            multiplayerReady = true;
            setupMultiplayerGameSync(game);
            
            updateWalletStatus(`Battle ${battleId}'a katıldınız - Oyun başlıyor!`);
        }

        // Load active battles
        async function loadActiveBattles() {
            const listDiv = document.getElementById('active-battles-list');
            if (!listDiv) return;
            
            listDiv.innerHTML = '<div style="text-align: center;">⏳ Aktif battle\'lar yükleniyor...</div>';
            
            try {
                // This would need to be implemented in the smart contract
                // For now, show a placeholder
                listDiv.innerHTML = `
                    <div style="text-align: center; color: #f39c12;">
                        📋 Aktif Battle Listesi<br>
                        <small>Smart contract'tan battle listesi çekilecek</small>
                    </div>
                `;
            } catch (error) {
                listDiv.innerHTML = '<div style="color: #e74c3c;">❌ Battle listesi yüklenemedi</div>';
            }
        }

        // Show active battles
        function showActiveBattles() {
            refreshOpenRooms();
        }

        // Update wallet status
        function updateWalletStatus(message) {
            const statusEl = document.getElementById('wallet-status');
            if (statusEl) {
                statusEl.textContent = message;
                setTimeout(() => {
                    if (statusEl) statusEl.textContent = '';
                }, 5000);
            }
        }

        // Timer UI'sini güncelle
        function updateTimerUI() {
            let timerBox = document.getElementById('timer-box');
            if (!timerBox) return;
            
            timerBox.style.display = 'block';
            const min = Math.floor(matchTimeLeft / 60);
            const sec = matchTimeLeft % 60;
            timerBox.textContent = `⏱️ ${min}:${sec.toString().padStart(2, '0')}`;
            
            // Son 30 saniyede kırmızı yap
            if (matchTimeLeft <= 30) {
                timerBox.style.color = '#e74c3c';
                timerBox.style.animation = 'pulse 1s infinite';
            }
        }

        // Battle sonucu dinle
        function setupBattleResultListener() {
            if (socket) {
                socket.on('battleResult', (result) => {
                    console.log('Battle result received:', result);
                    
                    // Oyun zaten bitmişse, sadece ödül butonunu aktif et
                    if (game && game.gameOver) {
                        enableClaimButtonIfWinner();
                    }
                    
                    // Battle sonucu bilgisini göster
                    const battleIdBox = document.getElementById('battle-id-box');
                    if (battleIdBox) {
                        battleIdBox.textContent = `Battle ${result.battleId} Completed - Winner: ${result.winner}`;
                        battleIdBox.style.background = result.winner === 'player1' ? '#4CAF50' : '#FF5722';
                    }
                });
            }
        }

        // Compact Open Rooms refresher (client → server)
        function refreshOpenRooms() {
            if (!socket) socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
            socket.emit('listRooms', (rooms) => {
                console.log('🔄 Received rooms from server:', rooms);
                const listDiv = document.getElementById('open-rooms-list');
                if (!listDiv) {
                    console.warn('⚠️ open-rooms-list element not found');
                    return;
                }
                
                // Convert server response to expected format - include all rooms with 1 player
                const openRooms = [];
                if (Array.isArray(rooms)) {
                    rooms.forEach(room => {
                        if (room.playersCount === 1) { // Remove meta requirement
                            openRooms.push({
                                roomId: room.roomId,
                                gameId: room.meta?.gameId || 'Quick Match',
                                stake: room.meta?.stake || 'Free',
                                createdAt: room.createdAt,
                                waitingTime: room.waitingTime || 0, // Add waiting time from server
                                meta: room.meta
                            });
                        }
                    });
                }
                
                console.log('🎮 Filtered open rooms:', openRooms);
                
                if (!openRooms || openRooms.length === 0) {
                    listDiv.innerHTML = '<div style="text-align:center; color:#888; padding:12px; font-style:italic;">No open rooms available</div>';
                    return;
                }
                listDiv.innerHTML = openRooms.map(r => {
                    const gameId = r.meta?.gameId || 'Unknown';
                    const stake = r.meta?.stake ? ethers.utils.formatUnits(r.meta.stake, 18) : '?';
                    const waitingTime = r.waitingTime ? `${Math.floor(r.waitingTime / 60)}:${(r.waitingTime % 60).toString().padStart(2, '0')}` : '0:00';
                    
                    return `
                        <div class='room-card' data-room='${r.roomId}' data-game-id='${gameId}' style='
                            border:1px solid #d4af37; 
                            padding:6px; 
                            border-radius:6px; 
                            min-width:120px; 
                            background: linear-gradient(135deg, #4a2c20, #3d2817);
                            text-align:center;
                            font-size:0.8em;
                        '>
                            <div style='color:#d4af37; font-weight:bold; margin-bottom:2px; font-size:0.8em;'>🎲 ${gameId}</div>
                            <div style='color:#f4e4c1; margin:1px 0; font-size:0.75em;'>💰 ${stake} HUNGX</div>
                            <div style='color:#888; font-size:0.7em; margin-bottom:4px;'>⏳ waiting ${waitingTime}</div>
                            <button class='btn seat-btn' data-room='${r.roomId}' data-game-id='${gameId}' style='
                                width:100%; 
                                padding:3px; 
                                background:#5d4e75; 
                                font-size:0.7em;
                                border:none;
                                border-radius:3px;
                                color:white;
                                cursor:pointer;
                            '>🎯 Join</button>
                        </div>`;
                }).join('');
                // Wire seat clicks
                listDiv.querySelectorAll('.seat-btn').forEach(btn => {
                    btn.onclick = () => {
                        const r = btn.getAttribute('data-room');
                        const gameId = btn.getAttribute('data-game-id');
                        
                        (async () => {
                            if (!(await ensureWalletReady())) {
                                alert('Please connect your wallet first!');
                                return;
                            }
                            // Check if room is still available before attempting join
                            socket.emit('listRooms', (currentRooms) => {
                                const stillAvailable = currentRooms.find(room => 
                                    room.roomId === r && 
                                    room.playersCount === 1
                                );
                                
                                if (!stillAvailable) {
                                    alert('❌ This room is no longer available!\n\nSomeone else may have joined or the creator disconnected.\nThe room list will refresh automatically.');
                                    refreshOpenRooms(); // Refresh the list
                                    return;
                                }
                                
                                // Room is still available, proceed with join
                                socket.emit('joinRoom', r, (success) => {
                                    if (success) {
                                        roomId = r;
                                        playerNumber = 2;
                                        // Try to fetch stake and gameId to auto-join chain-side
                                        socket.emit('getRoomMeta', r, async (resp) => {
                                            if (resp && resp.success && resp.meta) {
                                                if (!currentGameId && resp.meta.gameId) currentGameId = resp.meta.gameId;
                                                try {
                                                    if (resp.meta.stake) {
                                                        await ensureApproveUnlimited();
                                                        const tx = await moduleContract.joinMultiplayerGame(currentGameId, resp.meta.stake, { gasLimit: 400000 });
                                                        await tx.wait();
                                                    }
                                                } catch (e) {
                                                    console.warn('Auto-join on-chain failed:', e?.reason || e?.message || e);
                                                }
                                            }
                                        });
                                        socket.on('startGame', (gameData) => {
                                            console.log('🎮 Room join startGame received:', gameData);
                                            startBoardAndTimer();
                                            // Subscribe to server timer updates
                                            if (socket && socket.off) socket.off('timerUpdate');
                                            socket.on('timerUpdate', (t) => {
                                                updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                                            });
                                            multiplayerReady = true;
                                            setupMultiplayerGameSync(game);
                                            if (socket && roomId) {
                                                socket.emit('requestSync');
                                            }
                                            showStatus(`🎮 Joined room game! You are Player ${playerNumber}`, 'success', 4000);
                                        });
                                    } else {
                                        alert('❌ Room not found or full!');
                                        refreshOpenRooms();
                                    }
                                });
                            });
                        })();
                        
                        // Check if room is still available before attempting join
                        socket.emit('listRooms', (currentRooms) => {
                            const stillAvailable = currentRooms.find(room => 
                                room.roomId === r && 
                                room.playersCount === 1
                            );
                            
                            if (!stillAvailable) {
                                alert('❌ This room is no longer available!\n\nSomeone else may have joined or the creator disconnected.\nThe room list will refresh automatically.');
                                refreshOpenRooms(); // Refresh the list
                                return;
                            }
                            
                            // Room is still available, proceed with join
                            socket.emit('joinRoom', r, (success) => {
                                if (success) {
                                    roomId = r;
                                    playerNumber = 2;
                                    // Try to fetch stake and gameId to auto-join chain-side
                                    socket.emit('getRoomMeta', r, async (resp) => {
                                        if (resp && resp.success && resp.meta) {
                                            if (!currentGameId && resp.meta.gameId) currentGameId = resp.meta.gameId;
                                            try {
                                                if (resp.meta.stake) {
                                                    await ensureApproveUnlimited();
                                                    const tx = await moduleContract.joinMultiplayerGame(currentGameId, resp.meta.stake, { gasLimit: 400000 });
                                                    await tx.wait();
                                                }
                                            } catch (e) {
                                                console.warn('Auto-join on-chain failed:', e?.reason || e?.message || e);
                                            }
                                        }
                                    });
                                    socket.on('startGame', (gameData) => {
                                        console.log('🎮 Room join startGame received:', gameData);
                                        startBoardAndTimer();
                                        // Subscribe to server timer updates
                                        if (socket && socket.off) socket.off('timerUpdate');
                                        socket.on('timerUpdate', (t) => {
                                            updateTimerPanelFromServer(t.remainingSeconds[0], t.remainingSeconds[1], t.currentPlayer);
                                        });
                                        multiplayerReady = true;
                                        setupMultiplayerGameSync(game);
                                        if (socket && roomId) {
                                            socket.emit('requestSync');
                                        }
                                        showStatus(`🎮 Joined room game! You are Player ${playerNumber}`, 'success', 4000);
                                    });
                                } else {
                                    alert('❌ Room join failed!\n\nPossible causes:\n- Room is now full (someone else joined first)\n- Room creator disconnected\n- Network issues\n\nThe room list will refresh automatically.');
                                    refreshOpenRooms(); // Auto-refresh the room list
                                }
                            });  // joinRoom callback kapanıyor
                        });      // listRooms callback kapanıyor  
                    };           // btn.onclick kapanıyor
                });              // forEach kapanıyor
            });                  // socket.emit('listRooms') callback kapanıyor
        }
        window.refreshOpenRooms = refreshOpenRooms;

        // (Temiz UI) Battle butonları kaldırıldı; minimal PvP UI yukarıdaki addBattleUI ile ekleniyor

        // Professional error boundary
        window.addEventListener('error', (e) => {
            console.error('Application error:', e.error);
            showStatus('⚠️ An error occurred. Please refresh the page.', 'error', 5000);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            showStatus('⚠️ Connection issue. Retrying...', 'warning', 3000);
        });

        // Mobile detection and setup
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   window.innerWidth <= 768;
        }
        
        function setupMobileFeatures() {
            if (isMobile()) {
                const mobileNotice = document.getElementById('mobile-notice');
                if (mobileNotice) {
                    mobileNotice.style.display = 'block';
                    setTimeout(() => {
                        mobileNotice.style.display = 'none';
                    }, 4000);
                }
                
                // Add touch event listeners for better mobile interaction
                document.addEventListener('touchstart', function() {}, {passive: true});
                
                // Prevent zoom on double tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function (event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
                
                // Mobile orientation change handler
                window.addEventListener('orientationchange', function() {
                    setTimeout(function() {
                        window.scrollTo(0, 0);
                        // Refresh layout
                        const gameContainer = document.querySelector('.game-container');
                        if (gameContainer) {
                            gameContainer.style.height = '100vh';
                        }
                    }, 100);
                });
                
                // Prevent context menu on long press
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    return false;
                });
            }
        }

        // Enhanced room system functions - Global scope
        window.showCreateRoomModal = function() {
            document.getElementById('create-room-modal').style.display = 'flex';
        }
        
        window.closeCreateRoomModal = function() {
            document.getElementById('create-room-modal').style.display = 'none';
        }
        
        window.createRoomWithStake = function() {
            const stakeInput = document.getElementById('room-stake-input');
            const stakeAmount = parseFloat(stakeInput.value);
            
            if (!stakeAmount || stakeAmount < 100) {
                alert('Please enter a valid stake amount (minimum 100 HUNGX)');
                return;
            }
            
            // Set the stake and start the game creation flow
            window.tempStakeAmount = stakeAmount;
            closeCreateRoomModal();
            startPvpGameFlow();
        }
        
        window.showJoinModal = function() {
            document.getElementById('join-modal').style.display = 'flex';
        }
        
        window.closeJoinModal = function() {
            document.getElementById('join-modal').style.display = 'none';
        }
        
        window.joinByGameId = function() {
            const gameIdInput = document.getElementById('join-game-id-input');
            const gameId = gameIdInput.value.trim();
            
            if (!gameId) {
                alert('Please enter a Game ID');
                return;
            }
            
            currentGameId = gameId;
            closeJoinModal();
            joinPvpGameFlow();
        }
        
        // Room listing and management functions - Global scope
        window.listOpenRooms = function() {
            if (!socket) socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
            socket.emit('listRooms', (rooms) => {
                console.log('📋 Received rooms:', rooms);
                const openRooms = [];
                
                // Server returns an array of room objects, not an object with room IDs as keys
                if (Array.isArray(rooms)) {
                    rooms.forEach(room => {
                        if (room.playersCount === 1 && room.meta) {
                            openRooms.push({
                                roomId: room.roomId,
                                gameId: room.meta.gameId,
                                stake: room.meta.stake,
                                createdAt: room.createdAt
                            });
                        }
                    });
                } else {
                    // Fallback for object format (if server changes)
                    Object.keys(rooms).forEach(roomId => {
                        const room = rooms[roomId];
                        if (room.players && room.players.length === 1 && room.meta) {
                            openRooms.push({
                                roomId: roomId,
                                gameId: room.meta.gameId,
                                stake: room.meta.stake,
                                createdAt: room.createdAt
                            });
                        }
                    });
                }
                
                console.log('📋 Open rooms found:', openRooms);
                updateOpenRoomsList(openRooms);
            });
        }
        
        window.updateOpenRoomsList = function(openRooms) {
            const listDiv = document.getElementById('open-rooms-list');
            const noRoomsMsg = document.getElementById('no-rooms-message');
            if (!listDiv) return;
            
            if (openRooms.length === 0) {
                listDiv.innerHTML = '';
                if (noRoomsMsg) noRoomsMsg.style.display = 'block';
                return;
            }
            
            if (noRoomsMsg) noRoomsMsg.style.display = 'none';
            
            // Enhanced room cards with stake display
            listDiv.innerHTML = openRooms.map(r => {
                const stakeAmount = r.stake ? ethers.utils.formatUnits(r.stake.toString(), 18) : 'Unknown';
                return `
                    <div class="room-card" style="
                        background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(244, 228, 193, 0.05));
                        border: 1px solid rgba(212, 175, 55, 0.3);
                        border-radius: 8px;
                        padding: 6px;
                        margin: 2px 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        transition: all 0.2s ease;
                        cursor: pointer;
                    " onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'" onclick="quickJoinRoom('${r.roomId}', '${r.gameId}', '${r.stake}')">
                        <div style="display: flex; flex-direction: column; gap: 2px;">
                            <div style="font-size: 0.8em; font-weight: bold; color: #d4af37;">
                                🎮 ${r.roomId}
                            </div>
                            <div style="font-size: 0.7em; color: #f4e4c1;">
                                💰 ${stakeAmount} HUNGX
                            </div>
                        </div>
                        <button class="btn" style="
                            padding: 2px 6px; 
                            font-size: 0.7em; 
                            background: linear-gradient(135deg, #4CAF50, #45a049);
                            border: none;
                            color: white;
                        " onclick="event.stopPropagation(); quickJoinRoom('${r.roomId}', '${r.gameId}', '${r.stake}')">
                            ⚡ Join
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        // Quick join function for rooms
        window.quickJoinRoom = function(roomId, gameId, stake) {
            console.log(`🚀 Quick joining room ${roomId} with stake ${stake}`);
            
            // Set the game ID for joining
            currentGameId = gameId;
            
            // Start the join process
            joinPvpGameFlow();
        }
        
        // Refresh rooms function
        window.refreshRooms = function() {
            showStatus('🔄 Refreshing rooms...', 'info', 1000);
            listOpenRooms();
        }
        
        // Update Game ID display in UI
        function updateGameIdDisplay(gameId, status, stakeAmount = null) {
            const gameInfoEl = document.getElementById('battle-queue-info');
            const currentPlayerEl = document.querySelector('.current-player');
            
            let statusText = '';
            let statusColor = '#d4af37';
            let actionButton = '';
            
            switch(status) {
                case 'created':
                    statusText = `🎯 Game ${gameId} Created!`;
                    statusColor = '#4CAF50';
                    actionButton = `<div style="margin-top: 8px; font-size: 0.8em; color: #f4e4c1;">Share Game ID: <span style="background: rgba(0,0,0,0.2); padding: 2px 6px; border-radius: 4px; font-family: monospace;">${gameId}</span></div>`;
                    break;
                case 'joining':
                    statusText = `⚡ Joining Game ${gameId}${stakeAmount ? ` (${stakeAmount} HUNGX)` : ''}...`;
                    statusColor = '#ff9800';
                    break;
                case 'active':
                    statusText = `🎮 Game ${gameId} - Active Match!`;
                    statusColor = '#2196F3';
                    break;
                default:
                    statusText = `🎲 Game ID: ${gameId}`;
            }
            
            if (gameInfoEl) {
                gameInfoEl.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(244, 228, 193, 0.05));
                        border: 1px solid ${statusColor};
                        border-radius: 8px;
                        padding: 8px;
                        margin: 4px 0;
                        text-align: center;
                        color: ${statusColor};
                        font-weight: bold;
                        font-size: 0.9em;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        animation: ${status === 'created' ? 'glow 2s ease-in-out infinite alternate' : 'none'};
                    ">
                        ${statusText}
                        ${actionButton}
                    </div>
                `;
            }
            
            // Also update current player display
            if (currentPlayerEl && status === 'active') {
                currentPlayerEl.style.display = 'block';
            }
            
            // Add copy to clipboard functionality for game ID
            if (status === 'created') {
                setTimeout(() => {
                    const gameIdSpan = gameInfoEl.querySelector('span');
                    if (gameIdSpan) {
                        gameIdSpan.style.cursor = 'pointer';
                        gameIdSpan.onclick = () => {
                            navigator.clipboard.writeText(gameId).then(() => {
                                showStatus('📋 Game ID copied to clipboard!', 'success', 1500);
                            });
                        };
                    }
                }, 100);
            }
        }

        // Auto-refresh rooms every 5 seconds when not in game
        setInterval(() => {
            if (!multiplayerReady) {
                refreshOpenRooms();
                console.log('🔄 Auto-refreshing open rooms (not in game)');
            }
        }, 5000);
        
        // ESC key support for modals
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const createModal = document.getElementById('create-room-modal');
                const joinModal = document.getElementById('join-modal');
                if (createModal && createModal.style.display === 'flex') {
                    closeCreateRoomModal();
                }
                if (joinModal && joinModal.style.display === 'flex') {
                    closeJoinModal();
                }
            }
        });

        // Sayfa yüklendiğinde otomatik olarak oyunu başlat
        function initializeGame() {
            console.log('🚀 Coffee Checkers initializing...');
            setupMobileFeatures();
            showStatus('🎮 Welcome! Connect wallet to start.', 'info', 3000);
            
            // Start listing rooms immediately
            setTimeout(() => {
                listOpenRooms();
            }, 1000);
            
            // UI already integrated in new layout
            
            // Try to restore previous session first
            const savedSession = restoreGameSession();
            if (savedSession && savedSession.roomId && savedSession.currentGameId) {
                console.log('🔄 Restoring previous game session...');
                
                // Restore session variables
                roomId = savedSession.roomId;
                playerNumber = savedSession.playerNumber;
                currentGameId = savedSession.currentGameId;
                userAddress = savedSession.userAddress;
                currentWalletType = savedSession.currentWalletType;
                
                // Update UI to show restored wallet
                if (userAddress) updateWalletUI();
                
                // Reconnect to Socket.IO
                if (!socket) {
                    socket = io(undefined, { transports: (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? ['websocket', 'polling'] : ['websocket'] });
                    console.log('🔌 Socket reconnected');
                }
                
                // Try to rejoin the room
                socket.emit('joinRoom', roomId, (success) => {
                    if (success) {
                        console.log(`🚪 Rejoined room: ${roomId} as Player ${playerNumber}`);
                        multiplayerReady = true;
                        
                        // Restore game state if available
                        const savedGameState = restoreGameState();
                        if (savedGameState && savedGameState.gameState) {
                            game = new CoffeeCheckersRussian();
                            game.importState(savedGameState.gameState);
                            startBoardAndTimer();
                            setupMultiplayerGameSync(game);
                            console.log('🎮 Game state restored successfully');
                        } else {
                            // Wait for current game state from server
                            game = new CoffeeCheckersRussian();
                            setupMultiplayerGameSync(game);
                        }
                        
                        alert('🔄 Game session restored!\nReconnected to your multiplayer game.');
                    } else {
                        console.log('❌ Failed to rejoin room, starting fresh');
                        clearGameData();
            newGame(false);
                    }
                });
            } else {
                // No saved session, start fresh
                newGame(false);
            }
            
            // Battle result listener'ını kur
            setupBattleResultListener();
            
            console.log('Game initialization complete');
        }

        // Gelişmiş battle ödül sistemi
        async function completeBattleAndClaim() {
            if (!currentBattleId) {
                alert('No active battle found!');
                return;
            }
            
            if (!isWinner()) {
                alert('Only the winner can claim the reward!');
                return;
            }
            
            try {
                // Battle'ı blockchain'de tamamla
                const tx = await moduleContract.completeBattleAuto(currentBattleId);
                await tx.wait();
                
                alert('🎉 Congrats! Battle reward claimed successfully!');
                
                // UI'yi güncelle
            const claimBtn = document.getElementById('claim-game-reward-btn');
                if (claimBtn) {
                    claimBtn.textContent = 'Reward Claimed ✅';
                    claimBtn.disabled = true;
                    claimBtn.style.opacity = '0.5';
                }
                
                // Battle ID box'ını güncelle
                const battleIdBox = document.getElementById('battle-id-box');
                if (battleIdBox) {
                    battleIdBox.textContent = `Battle ${currentBattleId} - Reward Claimed ✅`;
                    battleIdBox.style.background = '#4CAF50';
                }
                
            } catch (error) {
                alert('Claim failed: ' + (error.reason || error.message));
                console.error('Claim error:', error);
            }
        }

        // Battle durumu sürekli kontrol et
        async function monitorBattleStatus() {
            if (!currentBattleId || !socket) return;
            
            try {
                socket.emit('getBattleStatus', currentBattleId, (response) => {
                    if (response.success) {
                        const status = response.status;
                        const battleIdBox = document.getElementById('battle-id-box');
                        
                        if (status === 0) { // Pending
                            if (battleIdBox) battleIdBox.textContent = `Battle ${currentBattleId} - Waiting for opponent...`;
                        } else if (status === 1) { // Active
                            if (battleIdBox) battleIdBox.textContent = `Battle ${currentBattleId} - Active`;
                        } else if (status === 2) { // Completed
                            if (battleIdBox) {
                                battleIdBox.textContent = `Battle ${currentBattleId} - Completed`;
                                battleIdBox.style.background = '#4CAF50';
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Battle status check failed:', error);
            }
        }

        // PvP UI now integrated in main layout
        setupBattleResultListener();

        // Battle durumunu periyodik kontrol et
        setInterval(monitorBattleStatus, 10000); // 10 saniyede bir

        // === UI FONKSİYONLARI ===
        function changeTheme(themeName) {
            themeManager.setTheme(themeName);
            showStatus(`🎨 Theme changed to ${themeManager.themes[themeName].name}`, 'success', 2000);
        }
        
        function toggleSound() {
            const enabled = soundManager.toggle();
            const button = document.getElementById('sound-toggle');
            if (button) {
                button.textContent = enabled ? '🔊 Sound ON' : '🔇 Sound OFF';
            }
            soundManager.play('click');
            showStatus(enabled ? '🔊 Sound enabled' : '🔇 Sound disabled', 'info', 1500);
        }
        
        // === Custom piece sound (move only) ===
        async function handlePieceSoundFile(file) {
            if (!file) return;
            try {
                const b64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(String(reader.result).split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
                const arrayBuff = Uint8Array.from(atob(b64), c => c.charCodeAt(0)).buffer;
                const audioBuffer = await soundManager.context.decodeAudioData(arrayBuff.slice(0));
                soundManager.customBuffers = soundManager.customBuffers || {};
                soundManager.customBuffers['move'] = audioBuffer;
                localStorage.setItem('coffeeCheckers_custom_sounds', JSON.stringify({ move: b64 }));
                showStatus('✅ Custom move sound set', 'success', 2000);
                soundManager.play('move');
            } catch (e) {
                console.error('Failed to set custom move sound:', e);
                showStatus('❌ Failed to set custom move sound', 'error', 2000);
            }
        }
        
        async function startQuickMatch() {
            if (!userAddress) {
                showStatus('❌ Connect wallet first!', 'error', 3000);
                return;
            }
            
            const stakeInput = prompt('Enter stake amount (HUNGX):', '100');
            if (!stakeInput || isNaN(stakeInput) || parseFloat(stakeInput) <= 0) {
                showStatus('❌ Invalid stake amount', 'error', 2000);
                return;
            }
            
            const success = quickMatch.startQuickMatch(parseFloat(stakeInput));
            if (!success) {
                showStatus('❌ Already searching for match', 'warning', 2000);
            }
        }
        
        // === SOCKET EVENTS (Quick Match) ===
        if (socket) {
            socket.on('quickMatchFound', (matchData) => {
                console.log('📨 Socket received quickMatchFound:', matchData);
                quickMatch.onMatchFound(matchData);
            });
            
            socket.on('quickMatchTimeout', () => {
                quickMatch.matchmaking = false;
                showStatus('⏰ No match found, try again', 'warning', 3000);
            });
            
            // Enhanced room join success handler
            socket.on('roomJoined', (data) => {
                console.log('🚪 Room joined successfully:', data);
                if (data.roomId === roomId && data.playerNumber === playerNumber) {
                    // Confirm multiplayer setup
                    showStatus(`✅ Connected to room ${data.roomId} as Player ${data.playerNumber}`, 'success', 3000);
                }
            });
            
            // Handle game start from server
            socket.on('gameStart', (gameData) => {
                console.log('🎮 Game start event received:', gameData);
                
                if (!multiplayerReady) {
                    // Activate multiplayer mode if not already active
                    multiplayerReady = true;
                    
                    // Ensure AI is disabled
                    if (aiPlayer.isActive) {
                        aiPlayer.deactivate();
                        console.log('🤖 AI deactivated via gameStart event');
                    }
                    
                    // Reset game state
                    if (game) {
                        game.resetGame();
                    } else {
                        game = new CoffeeCheckersRussian();
                        window.game = game;
                    }
                    
                    // Setup sync
                    setupMultiplayerGameSync(game);
                    
                    showStatus('🎯 Multiplayer game synchronized!', 'success', 3000);
                }
            });
        }
        
        // Global fonksiyonları window'a ekle
        window.connectWallet = connectWallet;
        window.startMultiplayer = startMultiplayer;
        window.claimBattleReward = completeBattleAndClaim;
        window.changeTheme = changeTheme;
        window.toggleSound = toggleSound;
        window.startQuickMatch = startQuickMatch;
        window.handlePieceSoundFile = handlePieceSoundFile;

        // Oyunu başlat
        initializeGame();

    }); // DOMContentLoaded event listener sonu
    </script>
</body>
</html>